<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tutorial 19: Mouse and Joystick</title>
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Wanted to avoid copying .css to each folder, so copied default .css from doxyen in here, kicked out most stuff we don't need for examples and modified some a little bit. 
     Target was having a single html in each example folder which is created from the main.cpp files and needs no files besides some images below media folder.
     Feel free to improve :)
	 -->
<style>
body, table, div, p, dl {
	font: 400 14px/22px;
}
body {
	background-color: #F0F0F0;
	color: black;
	margin-left: 5%;
	margin-right: 5%;
}
p.reference, p.definition {
	font: 400 14px/22px;
}
.title {
	font: 400 14px/28px;
	font-size: 150%;
	font-weight: bold;
	margin: 10px 2px;
}
h1, h2, h3, h4, h5, h6 {
	-webkit-transition: text-shadow 0.5s linear;
	-moz-transition: text-shadow 0.5s linear;
	-ms-transition: text-shadow 0.5s linear;
	-o-transition: text-shadow 0.5s linear;
	transition: text-shadow 0.5s linear;
	margin-right: 15px;
}
caption {
	font-weight: bold;
}
h3.version {
	font-size: 90%;
	text-align: center;
}
a {
	color: #3D578C;
	font-weight: normal;
	text-decoration: none;
}
.contents a:visited {
	color: #4665A2;
}
a:hover {
	text-decoration: underline;
}
a.el {
	font-weight: bold;
}
a.code, a.code:visited, a.line, a.line:visited {
	color: #4665A2; 
}
a.codeRef, a.codeRef:visited, a.lineRef, a.lineRef:visited {
	color: #4665A2; 
}
pre.fragment {
	border: 1px solid #C4CFE5;
	background-color: #FBFCFD;
	padding: 4px 6px;
	margin: 4px 8px 4px 2px;
	overflow: auto;
	word-wrap: break-word;
	font-size:  9pt;
	line-height: 125%;
	font-family: monospace, fixed;
	font-size: 105%;
}
div.fragment {
	padding: 0px;
	margin: 4px 8px 4px 2px;
	background-color: #FBFCFD;
	border: 1px solid #C4CFE5;
}
div.line {
	font-family: monospace, fixed;
	font-size: 13px;
	min-height: 13px;
	line-height: 1.0;
	text-wrap: unrestricted;
	white-space: -moz-pre-wrap; /* Moz */
	white-space: -pre-wrap;     /* Opera 4-6 */
	white-space: -o-pre-wrap;   /* Opera 7 */
	white-space: pre-wrap;      /* CSS3  */
	word-wrap: break-word;      /* IE 5.5+ */
	text-indent: -53px;
	padding-left: 53px;
	padding-bottom: 0px;
	margin: 0px;
	-webkit-transition-property: background-color, box-shadow;
	-webkit-transition-duration: 0.5s;
	-moz-transition-property: background-color, box-shadow;
	-moz-transition-duration: 0.5s;
	-ms-transition-property: background-color, box-shadow;
	-ms-transition-duration: 0.5s;
	-o-transition-property: background-color, box-shadow;
	-o-transition-duration: 0.5s;
	transition-property: background-color, box-shadow;
	transition-duration: 0.5s;
}
div.contents {
	margin-top: 10px;
	margin-left: 12px;
	margin-right: 8px;
}
div.center {
	text-align: center;
	margin-top: 0px;
	margin-bottom: 0px;
	padding: 0px;
}
div.center img {
	border: 0px;
}
span.keyword {
	color: #008000
}
span.keywordtype {
	color: #604020
}
span.keywordflow {
	color: #e08000
}
span.comment {
	color: #800000
}
span.preprocessor {
	color: #806020
}
span.stringliteral {
	color: #002080
}
span.charliteral {
	color: #008080
}
blockquote {
	background-color: #F7F8FB;
	border-left: 2px solid #9CAFD4;
	margin: 0 24px 0 4px;
	padding: 0 12px 0 16px;
}
hr {
	height: 0px;
	border: none;
	border-top: 1px solid #4A6AAA;
}
address {
	font-style: normal;
	color: #2A3D61;
}
div.header {
	background-image:url('nav_h.png');
	background-repeat:repeat-x;
	background-color: #F9FAFC;
	margin:  0px;
	border-bottom: 1px solid #C4CFE5;
}
div.headertitle {
	padding: 5px 5px 5px 10px;
}
.image {
	text-align: center;
}
.caption {
	font-weight: bold;
}
div.zoom {
	border: 1px solid #90A5CE;
}
tr.heading h2 {
	margin-top: 12px;
	margin-bottom: 4px;
}
</style>
</head>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!--END TITLEAREA-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 19: Mouse and Joystick </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="../../media/example_screenshots/019shot.jpg" alt="019shot.jpg"/>
</div>
 <p>This tutorial builds on example 04.Movement which showed how to handle keyboard events in Irrlicht. Here we'll handle mouse events and joystick events, if you have a joystick connected and a device that supports joysticks. These are currently Windows, Linux and SDL devices. </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef _MSC_VER</span></div><div class="line"><span class="comment">// We&#39;ll define this to stop MSVC complaining about sprintf().</span></div><div class="line"><span class="preprocessor">#define _CRT_SECURE_NO_WARNINGS</span></div><div class="line"><span class="preprocessor">#pragma comment(lib, &quot;Irrlicht.lib&quot;)</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;irrlicht.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;driverChoice.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>irr;</div></div><!-- fragment --><p> Just as we did in example 04.Movement, we'll store the latest state of the mouse and the first joystick, updating them as we receive events. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyEventReceiver : <span class="keyword">public</span> IEventReceiver</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// We&#39;ll create a struct to record info on the mouse state</span></div><div class="line">    <span class="keyword">struct </span>SMouseState</div><div class="line">    {</div><div class="line">        core::position2di Position;</div><div class="line">        <span class="keywordtype">bool</span> LeftButtonDown;</div><div class="line">        SMouseState() : LeftButtonDown(false) { }</div><div class="line">    } MouseState;</div><div class="line"></div><div class="line">    <span class="comment">// This is the one method that we have to implement</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> OnEvent(<span class="keyword">const</span> SEvent&amp; event)</div><div class="line">    {</div><div class="line">        <span class="comment">// Remember the mouse state</span></div><div class="line">        <span class="keywordflow">if</span> (event.EventType == irr::EET_MOUSE_INPUT_EVENT)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">switch</span>(event.MouseInput.Event)</div><div class="line">            {</div><div class="line">            <span class="keywordflow">case</span> EMIE_LMOUSE_PRESSED_DOWN:</div><div class="line">                MouseState.LeftButtonDown = <span class="keyword">true</span>;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">case</span> EMIE_LMOUSE_LEFT_UP:</div><div class="line">                MouseState.LeftButtonDown = <span class="keyword">false</span>;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">case</span> EMIE_MOUSE_MOVED:</div><div class="line">                MouseState.Position.X = <span class="keyword">event</span>.MouseInput.X;</div><div class="line">                MouseState.Position.Y = <span class="keyword">event</span>.MouseInput.Y;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">default</span>:</div><div class="line">                <span class="comment">// We won&#39;t use the wheel</span></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// The state of each connected joystick is sent to us</span></div><div class="line">        <span class="comment">// once every run() of the Irrlicht device.  Store the</span></div><div class="line">        <span class="comment">// state of the first joystick, ignoring other joysticks.</span></div><div class="line">        <span class="comment">// This is currently only supported on Windows and Linux.</span></div><div class="line">        <span class="keywordflow">if</span> (event.EventType == irr::EET_JOYSTICK_INPUT_EVENT</div><div class="line">            &amp;&amp; event.JoystickEvent.Joystick == 0)</div><div class="line">        {</div><div class="line">            JoystickState = <span class="keyword">event</span>.JoystickEvent;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> SEvent::SJoystickEvent &amp; GetJoystickState(<span class="keywordtype">void</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> JoystickState;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> SMouseState &amp; GetMouseState(<span class="keywordtype">void</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> MouseState;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    MyEventReceiver()</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    SEvent::SJoystickEvent JoystickState;</div><div class="line">};</div></div><!-- fragment --><p> The event receiver for keeping the pressed keys is ready, the actual responses will be made inside the render loop, right before drawing the scene. So lets just create an irr::IrrlichtDevice and the scene node we want to move. We also create some other additional scene nodes, to show that there are also some different possibilities to move and animate scene nodes. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// ask user for driver</span></div><div class="line">    video::E_DRIVER_TYPE driverType=driverChoiceConsole();</div><div class="line">    <span class="keywordflow">if</span> (driverType==video::EDT_COUNT)</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line"></div><div class="line">    <span class="comment">// create device</span></div><div class="line">    MyEventReceiver receiver;</div><div class="line"></div><div class="line">    IrrlichtDevice* device = createDevice(driverType,</div><div class="line">            core::dimension2d&lt;u32&gt;(640, 480), 16, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, &amp;receiver);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (device == 0)</div><div class="line">        <span class="keywordflow">return</span> 1; <span class="comment">// could not create selected driver.</span></div><div class="line"></div><div class="line"></div><div class="line">    core::array&lt;SJoystickInfo&gt; joystickInfo;</div><div class="line">    <span class="keywordflow">if</span>(device-&gt;activateJoysticks(joystickInfo))</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Joystick support is enabled and &quot;</span> &lt;&lt; joystickInfo.size() &lt;&lt; <span class="stringliteral">&quot; joystick(s) are present.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span>(u32 joystick = 0; joystick &lt; joystickInfo.size(); ++joystick)</div><div class="line">        {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Joystick &quot;</span> &lt;&lt; joystick &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; std::endl;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;\tName: &#39;&quot;</span> &lt;&lt; joystickInfo[joystick].Name.c_str() &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;\tAxes: &quot;</span> &lt;&lt; joystickInfo[joystick].Axes &lt;&lt; std::endl;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;\tButtons: &quot;</span> &lt;&lt; joystickInfo[joystick].Buttons &lt;&lt; std::endl;</div><div class="line"></div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;\tHat is: &quot;</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">switch</span>(joystickInfo[joystick].PovHat)</div><div class="line">            {</div><div class="line">            <span class="keywordflow">case</span> SJoystickInfo::POV_HAT_PRESENT:</div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;present&quot;</span> &lt;&lt; std::endl;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">case</span> SJoystickInfo::POV_HAT_ABSENT:</div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;absent&quot;</span> &lt;&lt; std::endl;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">case</span> SJoystickInfo::POV_HAT_UNKNOWN:</div><div class="line">            <span class="keywordflow">default</span>:</div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;unknown&quot;</span> &lt;&lt; std::endl;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Joystick support is not enabled.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    core::stringw tmp = L<span class="stringliteral">&quot;Irrlicht Joystick Example (&quot;</span>;</div><div class="line">    tmp += joystickInfo.size();</div><div class="line">    tmp += <span class="stringliteral">&quot; joysticks)&quot;</span>;</div><div class="line">    device-&gt;setWindowCaption(tmp.c_str());</div><div class="line"></div><div class="line">    video::IVideoDriver* driver = device-&gt;getVideoDriver();</div><div class="line">    scene::ISceneManager* smgr = device-&gt;getSceneManager();</div></div><!-- fragment --><p> We'll create an arrow mesh and move it around either with the joystick axis/hat, or make it follow the mouse pointer.</p><div class="fragment"><div class="line">scene::ISceneNode * node = smgr-&gt;addMeshSceneNode(</div><div class="line">    smgr-&gt;addArrowMesh( <span class="stringliteral">&quot;Arrow&quot;</span>,</div><div class="line">            video::SColor(255, 255, 0, 0),</div><div class="line">            video::SColor(255, 0, 255, 0),</div><div class="line">            16,16,</div><div class="line">            2.f, 1.3f,</div><div class="line">            0.1f, 0.6f</div><div class="line">            )</div><div class="line">    );</div><div class="line">node-&gt;setMaterialFlag(video::EMF_LIGHTING, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">scene::ICameraSceneNode * camera = smgr-&gt;addCameraSceneNode();</div><div class="line">camera-&gt;setPosition(core::vector3df(0, 0, -10));</div><div class="line"></div><div class="line"><span class="comment">// As in example 04, we&#39;ll use framerate independent movement.</span></div><div class="line">u32 then = device-&gt;getTimer()-&gt;getTime();</div><div class="line"><span class="keyword">const</span> f32 MOVEMENT_SPEED = 5.f;</div><div class="line"></div><div class="line"><span class="keywordflow">while</span>(device-&gt;run())</div><div class="line">{</div><div class="line">    <span class="comment">// Work out a frame delta time.</span></div><div class="line">    <span class="keyword">const</span> u32 now = device-&gt;getTimer()-&gt;getTime();</div><div class="line">    <span class="keyword">const</span> f32 frameDeltaTime = (f32)(now - then) / 1000.f; <span class="comment">// Time in seconds</span></div><div class="line">    then = now;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> movedWithJoystick = <span class="keyword">false</span>;</div><div class="line">    core::vector3df nodePosition = node-&gt;getPosition();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(joystickInfo.size() &gt; 0)</div><div class="line">    {</div><div class="line">        f32 moveHorizontal = 0.f; <span class="comment">// Range is -1.f for full left to +1.f for full right</span></div><div class="line">        f32 moveVertical = 0.f; <span class="comment">// -1.f for full down to +1.f for full up.</span></div><div class="line"></div><div class="line">        <span class="keyword">const</span> SEvent::SJoystickEvent &amp; joystickData = receiver.GetJoystickState();</div><div class="line"></div><div class="line">        <span class="comment">// We receive the full analog range of the axes, and so have to implement our</span></div><div class="line">        <span class="comment">// own dead zone.  This is an empirical value, since some joysticks have more</span></div><div class="line">        <span class="comment">// jitter or creep around the center point than others.  We&#39;ll use 5% of the</span></div><div class="line">        <span class="comment">// range as the dead zone, but generally you would want to give the user the</span></div><div class="line">        <span class="comment">// option to change this.</span></div><div class="line">        <span class="keyword">const</span> f32 DEAD_ZONE = 0.05f;</div><div class="line"></div><div class="line">        moveHorizontal =</div><div class="line">            (f32)joystickData.Axis[SEvent::SJoystickEvent::AXIS_X] / 32767.f;</div><div class="line">        <span class="keywordflow">if</span>(fabs(moveHorizontal) &lt; DEAD_ZONE)</div><div class="line">            moveHorizontal = 0.f;</div><div class="line"></div><div class="line">        moveVertical =</div><div class="line">            (f32)joystickData.Axis[SEvent::SJoystickEvent::AXIS_Y] / -32767.f;</div><div class="line">        <span class="keywordflow">if</span>(fabs(moveVertical) &lt; DEAD_ZONE)</div><div class="line">            moveVertical = 0.f;</div><div class="line"></div><div class="line">        <span class="comment">// POV hat info is only currently supported on Windows, but the value is</span></div><div class="line">        <span class="comment">// guaranteed to be 65535 if it&#39;s not supported, so we can check its range.</span></div><div class="line">        <span class="keyword">const</span> u16 povDegrees = joystickData.POV / 100;</div><div class="line">        <span class="keywordflow">if</span>(povDegrees &lt; 360)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span>(povDegrees &gt; 0 &amp;&amp; povDegrees &lt; 180)</div><div class="line">                moveHorizontal = 1.f;</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(povDegrees &gt; 180)</div><div class="line">                moveHorizontal = -1.f;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span>(povDegrees &gt; 90 &amp;&amp; povDegrees &lt; 270)</div><div class="line">                moveVertical = -1.f;</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(povDegrees &gt; 270 || povDegrees &lt; 90)</div><div class="line">                moveVertical = +1.f;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>(!core::equals(moveHorizontal, 0.f) || !core::equals(moveVertical, 0.f))</div><div class="line">        {</div><div class="line">            nodePosition.X += MOVEMENT_SPEED * frameDeltaTime * moveHorizontal;</div><div class="line">            nodePosition.Y += MOVEMENT_SPEED * frameDeltaTime * moveVertical;</div><div class="line">            movedWithJoystick = <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// If the arrow node isn&#39;t being moved with the joystick, then have it follow the mouse cursor.</span></div><div class="line">    <span class="keywordflow">if</span>(!movedWithJoystick)</div><div class="line">    {</div><div class="line">        <span class="comment">// Create a ray through the mouse cursor.</span></div><div class="line">        core::line3df ray = smgr-&gt;getSceneCollisionManager()-&gt;getRayFromScreenCoordinates(</div><div class="line">            receiver.GetMouseState().Position, camera);</div><div class="line"></div><div class="line">        <span class="comment">// And intersect the ray with a plane around the node facing towards the camera.</span></div><div class="line">        core::plane3df plane(nodePosition, core::vector3df(0, 0, -1));</div><div class="line">        core::vector3df mousePosition;</div><div class="line">        <span class="keywordflow">if</span>(plane.getIntersectionWithLine(ray.start, ray.getVector(), mousePosition))</div><div class="line">        {</div><div class="line">            <span class="comment">// We now have a mouse position in 3d space; move towards it.</span></div><div class="line">            core::vector3df toMousePosition(mousePosition - nodePosition);</div><div class="line">            <span class="keyword">const</span> f32 availableMovement = MOVEMENT_SPEED * frameDeltaTime;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span>(toMousePosition.getLength() &lt;= availableMovement)</div><div class="line">                nodePosition = mousePosition; <span class="comment">// Jump to the final position</span></div><div class="line">            <span class="keywordflow">else</span></div><div class="line">                nodePosition += toMousePosition.normalize() * availableMovement; <span class="comment">// Move towards it</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    node-&gt;setPosition(nodePosition);</div><div class="line"></div><div class="line">    <span class="comment">// Turn lighting on and off depending on whether the left mouse button is down.</span></div><div class="line">    node-&gt;setMaterialFlag(video::EMF_LIGHTING, receiver.GetMouseState().LeftButtonDown);</div><div class="line"></div><div class="line">    driver-&gt;beginScene(video::ECBF_COLOR | video::ECBF_DEPTH, video::SColor(255,113,113,133));</div><div class="line">    smgr-&gt;drawAll(); <span class="comment">// draw the 3d scene</span></div><div class="line">    driver-&gt;endScene();</div><div class="line">}</div></div><!-- fragment --><p> In the end, delete the Irrlicht device. </p><div class="fragment"><div class="line">    device-&gt;drop();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<p>&nbsp;</p>
</body>
</html>
