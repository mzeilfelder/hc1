<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tutorial 20: Managed Lights</title>
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Wanted to avoid copying .css to each folder, so copied default .css from doxyen in here, kicked out most stuff we don't need for examples and modified some a little bit. 
     Target was having a single html in each example folder which is created from the main.cpp files and needs no files besides some images below media folder.
     Feel free to improve :)
	 -->
<style>
body, table, div, p, dl {
	font: 400 14px/22px;
}
body {
	background-color: #F0F0F0;
	color: black;
	margin-left: 5%;
	margin-right: 5%;
}
p.reference, p.definition {
	font: 400 14px/22px;
}
.title {
	font: 400 14px/28px;
	font-size: 150%;
	font-weight: bold;
	margin: 10px 2px;
}
h1, h2, h3, h4, h5, h6 {
	-webkit-transition: text-shadow 0.5s linear;
	-moz-transition: text-shadow 0.5s linear;
	-ms-transition: text-shadow 0.5s linear;
	-o-transition: text-shadow 0.5s linear;
	transition: text-shadow 0.5s linear;
	margin-right: 15px;
}
caption {
	font-weight: bold;
}
h3.version {
	font-size: 90%;
	text-align: center;
}
a {
	color: #3D578C;
	font-weight: normal;
	text-decoration: none;
}
.contents a:visited {
	color: #4665A2;
}
a:hover {
	text-decoration: underline;
}
a.el {
	font-weight: bold;
}
a.code, a.code:visited, a.line, a.line:visited {
	color: #4665A2; 
}
a.codeRef, a.codeRef:visited, a.lineRef, a.lineRef:visited {
	color: #4665A2; 
}
pre.fragment {
	border: 1px solid #C4CFE5;
	background-color: #FBFCFD;
	padding: 4px 6px;
	margin: 4px 8px 4px 2px;
	overflow: auto;
	word-wrap: break-word;
	font-size:  9pt;
	line-height: 125%;
	font-family: monospace, fixed;
	font-size: 105%;
}
div.fragment {
	padding: 0px;
	margin: 4px 8px 4px 2px;
	background-color: #FBFCFD;
	border: 1px solid #C4CFE5;
}
div.line {
	font-family: monospace, fixed;
	font-size: 13px;
	min-height: 13px;
	line-height: 1.0;
	text-wrap: unrestricted;
	white-space: -moz-pre-wrap; /* Moz */
	white-space: -pre-wrap;     /* Opera 4-6 */
	white-space: -o-pre-wrap;   /* Opera 7 */
	white-space: pre-wrap;      /* CSS3  */
	word-wrap: break-word;      /* IE 5.5+ */
	text-indent: -53px;
	padding-left: 53px;
	padding-bottom: 0px;
	margin: 0px;
	-webkit-transition-property: background-color, box-shadow;
	-webkit-transition-duration: 0.5s;
	-moz-transition-property: background-color, box-shadow;
	-moz-transition-duration: 0.5s;
	-ms-transition-property: background-color, box-shadow;
	-ms-transition-duration: 0.5s;
	-o-transition-property: background-color, box-shadow;
	-o-transition-duration: 0.5s;
	transition-property: background-color, box-shadow;
	transition-duration: 0.5s;
}
div.contents {
	margin-top: 10px;
	margin-left: 12px;
	margin-right: 8px;
}
div.center {
	text-align: center;
	margin-top: 0px;
	margin-bottom: 0px;
	padding: 0px;
}
div.center img {
	border: 0px;
}
span.keyword {
	color: #008000
}
span.keywordtype {
	color: #604020
}
span.keywordflow {
	color: #e08000
}
span.comment {
	color: #800000
}
span.preprocessor {
	color: #806020
}
span.stringliteral {
	color: #002080
}
span.charliteral {
	color: #008080
}
blockquote {
	background-color: #F7F8FB;
	border-left: 2px solid #9CAFD4;
	margin: 0 24px 0 4px;
	padding: 0 12px 0 16px;
}
hr {
	height: 0px;
	border: none;
	border-top: 1px solid #4A6AAA;
}
address {
	font-style: normal;
	color: #2A3D61;
}
div.header {
	background-image:url('nav_h.png');
	background-repeat:repeat-x;
	background-color: #F9FAFC;
	margin:  0px;
	border-bottom: 1px solid #C4CFE5;
}
div.headertitle {
	padding: 5px 5px 5px 10px;
}
.image {
	text-align: center;
}
.caption {
	font-weight: bold;
}
div.zoom {
	border: 1px solid #90A5CE;
}
tr.heading h2 {
	margin-top: 12px;
	margin-bottom: 4px;
}
</style>
</head>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!--END TITLEAREA-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 20: Managed Lights </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="../../media/example_screenshots/020shot.jpg" alt="020shot.jpg"/>
</div>
 <p>Written by Colin MacDonald. This tutorial explains the use of the Light Manager of Irrlicht. It enables the use of more dynamic light sources than the actual hardware supports. Further applications of the Light Manager, such as per scene node callbacks, are left out for simplicity of the example. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;irrlicht.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;driverChoice.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;exampleHelper.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>irr;</div><div class="line"><span class="keyword">using namespace </span>core;</div><div class="line"></div><div class="line"><span class="preprocessor">#if defined(_MSC_VER)</span></div><div class="line"><span class="preprocessor">#pragma comment(lib, &quot;Irrlicht.lib&quot;)</span></div><div class="line"><span class="preprocessor">#endif // MSC_VER</span></div></div><!-- fragment --><p> Normally, you are limited to 8 dynamic lights per scene: this is a hardware limit. If you want to use more dynamic lights in your scene, then you can register an optional light manager that allows you to to turn lights on and off at specific point during rendering. You are still limited to 8 lights, but the limit is per scene node.</p>
<p>This is completely optional: if you do not register a light manager, then a default distance-based scheme will be used to prioritise hardware lights based on their distance from the active camera.</p>
<p>NO_MANAGEMENT disables the light manager and shows Irrlicht's default light behaviour. The 8 lights nearest to the camera will be turned on, and other lights will be turned off. In this example, this produces a funky looking but incoherent light display.</p>
<p>LIGHTS_NEAREST_NODE shows an implementation that turns on a limited number of lights per mesh scene node. If finds the 3 lights that are nearest to the node being rendered, and turns them on, turning all other lights off. This works, but as it operates on every light for every node, it does not scale well with many lights. The flickering you can see in this demo is due to the lights swapping their relative positions from the cubes (a deliberate demonstration of the limitations of this technique).</p>
<p>LIGHTS_IN_ZONE shows a technique for turning on lights based on a 'zone'. Each empty scene node is considered to be the parent of a zone. When nodes are rendered, they turn off all lights, then find their parent 'zone' and turn on all lights that are inside that zone, i.e. are descendents of it in the scene graph. This produces true 'local' lighting for each cube in this example. You could use a similar technique to locally light all meshes in (e.g.) a room, without the lights spilling out to other rooms.</p>
<p>This light manager is also an event receiver; this is purely for simplicity in this example, it's neither necessary nor recommended for a real application. </p><div class="fragment"><div class="line"><span class="keyword">class </span>CMyLightManager : <span class="keyword">public</span> scene::ILightManager, <span class="keyword">public</span> IEventReceiver</div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span></div><div class="line">    {</div><div class="line">        NO_MANAGEMENT,</div><div class="line">        LIGHTS_NEAREST_NODE,</div><div class="line">        LIGHTS_IN_ZONE</div><div class="line">    }</div><div class="line">    LightManagementMode;</div><div class="line"></div><div class="line">    LightManagementMode Mode;</div><div class="line">    LightManagementMode RequestedMode;</div><div class="line"></div><div class="line">    <span class="comment">// These data represent the state information that this light manager</span></div><div class="line">    <span class="comment">// is interested in.</span></div><div class="line">    scene::ISceneManager * SceneManager;</div><div class="line">    core::array&lt;scene::ISceneNode*&gt; * SceneLightList;</div><div class="line">    scene::E_SCENE_NODE_RENDER_PASS CurrentRenderPass;</div><div class="line">    scene::ISceneNode * CurrentSceneNode;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    CMyLightManager(scene::ISceneManager* sceneManager)</div><div class="line">        : Mode(NO_MANAGEMENT), RequestedMode(NO_MANAGEMENT),</div><div class="line">        SceneManager(sceneManager), SceneLightList(0),</div><div class="line">        CurrentRenderPass(scene::ESNRP_NONE), CurrentSceneNode(0)</div><div class="line">    { }</div><div class="line"></div><div class="line">    <span class="comment">// The input receiver interface, which just switches light management strategy</span></div><div class="line">    <span class="keywordtype">bool</span> OnEvent(<span class="keyword">const</span> SEvent &amp; event)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">bool</span> handled = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (event.EventType == irr::EET_KEY_INPUT_EVENT &amp;&amp; event.KeyInput.PressedDown)</div><div class="line">        {</div><div class="line">            handled = <span class="keyword">true</span>;</div><div class="line">            <span class="keywordflow">switch</span>(event.KeyInput.Key)</div><div class="line">            {</div><div class="line">            <span class="keywordflow">case</span> irr::KEY_KEY_1:</div><div class="line">                RequestedMode = NO_MANAGEMENT;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">case</span> irr::KEY_KEY_2:</div><div class="line">                RequestedMode = LIGHTS_NEAREST_NODE;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">case</span> irr::KEY_KEY_3:</div><div class="line">                RequestedMode = LIGHTS_IN_ZONE;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">default</span>:</div><div class="line">                handled = <span class="keyword">false</span>;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span>(NO_MANAGEMENT == RequestedMode)</div><div class="line">                SceneManager-&gt;setLightManager(0); <span class="comment">// Show that it&#39;s safe to register the light manager</span></div><div class="line">            <span class="keywordflow">else</span></div><div class="line">                SceneManager-&gt;setLightManager(<span class="keyword">this</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> handled;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// This is called before the first scene node is rendered.</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnPreRender(core::array&lt;scene::ISceneNode*&gt; &amp; lightList)</div><div class="line">    {</div><div class="line">        <span class="comment">// Update the mode; changing it here ensures that it&#39;s consistent throughout a render</span></div><div class="line">        Mode = RequestedMode;</div><div class="line"></div><div class="line">        <span class="comment">// Store the light list. I am free to alter this list until the end of OnPostRender().</span></div><div class="line">        SceneLightList = &amp;lightList;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Called after the last scene node is rendered.</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnPostRender()</div><div class="line">    {</div><div class="line">        <span class="comment">// Since light management might be switched off in the event handler, we&#39;ll turn all</span></div><div class="line">        <span class="comment">// lights on to ensure that they are in a consistent state. You wouldn&#39;t normally have</span></div><div class="line">        <span class="comment">// to do this when using a light manager, since you&#39;d continue to do light management</span></div><div class="line">        <span class="comment">// yourself.</span></div><div class="line">        <span class="keywordflow">for</span> (u32 i = 0; i &lt; SceneLightList-&gt;size(); i++)</div><div class="line">            (*SceneLightList)[i]-&gt;setVisible(<span class="keyword">true</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnRenderPassPreRender(scene::E_SCENE_NODE_RENDER_PASS renderPass)</div><div class="line">    {</div><div class="line">        <span class="comment">// I don&#39;t have to do anything here except remember which render pass I am in.</span></div><div class="line">        CurrentRenderPass = renderPass;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnRenderPassPostRender(scene::E_SCENE_NODE_RENDER_PASS renderPass)</div><div class="line">    {</div><div class="line">        <span class="comment">// I only want solid nodes to be lit, so after the solid pass, turn all lights off.</span></div><div class="line">        <span class="keywordflow">if</span> (scene::ESNRP_SOLID == renderPass)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">for</span> (u32 i = 0; i &lt; SceneLightList-&gt;size(); ++i)</div><div class="line">                (*SceneLightList)[i]-&gt;setVisible(<span class="keyword">false</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// This is called before the specified scene node is rendered</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnNodePreRender(scene::ISceneNode* node)</div><div class="line">    {</div><div class="line">        CurrentSceneNode = node;</div><div class="line"></div><div class="line">        <span class="comment">// This light manager only considers solid objects, but you are free to manipulate</span></div><div class="line">        <span class="comment">// lights during any phase, depending on your requirements.</span></div><div class="line">        <span class="keywordflow">if</span> (scene::ESNRP_SOLID != CurrentRenderPass)</div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">// And in fact for this example, I only want to consider lighting for cube scene</span></div><div class="line">        <span class="comment">// nodes.  You will probably want to deal with lighting for (at least) mesh /</span></div><div class="line">        <span class="comment">// animated mesh scene nodes as well.</span></div><div class="line">        <span class="keywordflow">if</span> (node-&gt;getType() != scene::ESNT_CUBE)</div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (LIGHTS_NEAREST_NODE == Mode)</div><div class="line">        {</div><div class="line">            <span class="comment">// This is a naive implementation that prioritises every light in the scene</span></div><div class="line">            <span class="comment">// by its proximity to the node being rendered.  This produces some flickering</span></div><div class="line">            <span class="comment">// when lights orbit closer to a cube than its &#39;zone&#39; lights.</span></div><div class="line">            <span class="keyword">const</span> vector3df nodePosition = node-&gt;getAbsolutePosition();</div><div class="line"></div><div class="line">            <span class="comment">// Sort the light list by prioritising them based on their distance from the node</span></div><div class="line">            <span class="comment">// that&#39;s about to be rendered.</span></div><div class="line">            array&lt;LightDistanceElement&gt; sortingArray;</div><div class="line">            sortingArray.reallocate(SceneLightList-&gt;size());</div><div class="line"></div><div class="line">            u32 i;</div><div class="line">            <span class="keywordflow">for</span>(i = 0; i &lt; SceneLightList-&gt;size(); ++i)</div><div class="line">            {</div><div class="line">                scene::ISceneNode* lightNode = (*SceneLightList)[i];</div><div class="line">                <span class="keyword">const</span> f64 distance = lightNode-&gt;getAbsolutePosition().getDistanceFromSQ(nodePosition);</div><div class="line">                sortingArray.push_back(LightDistanceElement(lightNode, distance));</div><div class="line">            }</div><div class="line"></div><div class="line">            sortingArray.sort();</div><div class="line"></div><div class="line">            <span class="comment">// The list is now sorted by proximity to the node.</span></div><div class="line">            <span class="comment">// Turn on the three nearest lights, and turn the others off.</span></div><div class="line">            <span class="keywordflow">for</span>(i = 0; i &lt; sortingArray.size(); ++i)</div><div class="line">                sortingArray[i].node-&gt;setVisible(i &lt; 3);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(LIGHTS_IN_ZONE == Mode)</div><div class="line">        {</div><div class="line">            <span class="comment">// Empty scene nodes are used to represent &#39;zones&#39;.  For each solid mesh that</span></div><div class="line">            <span class="comment">// is being rendered, turn off all lights, then find its &#39;zone&#39; parent, and turn</span></div><div class="line">            <span class="comment">// on all lights that are found under that node in the scene graph.</span></div><div class="line">            <span class="comment">// This is a general purpose algorithm that doesn&#39;t use any special</span></div><div class="line">            <span class="comment">// knowledge of how this particular scene graph is organised.</span></div><div class="line">            <span class="keywordflow">for</span> (u32 i = 0; i &lt; SceneLightList-&gt;size(); ++i)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">if</span> ((*SceneLightList)[i]-&gt;getType() != scene::ESNT_LIGHT)</div><div class="line">                    <span class="keywordflow">continue</span>;</div><div class="line">                scene::ILightSceneNode* lightNode = <span class="keyword">static_cast&lt;</span>scene::ILightSceneNode*<span class="keyword">&gt;</span>((*SceneLightList)[i]);</div><div class="line">                video::SLight &amp; lightData = lightNode-&gt;getLightData();</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (video::ELT_DIRECTIONAL != lightData.Type)</div><div class="line">                    lightNode-&gt;setVisible(<span class="keyword">false</span>);</div><div class="line">            }</div><div class="line"></div><div class="line">            scene::ISceneNode * parentZone = findZone(node);</div><div class="line">            <span class="keywordflow">if</span> (parentZone)</div><div class="line">                turnOnZoneLights(parentZone);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Called after the specified scene node is rendered</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnNodePostRender(scene::ISceneNode* node)</div><div class="line">    {</div><div class="line">        <span class="comment">// I don&#39;t need to do any light management after individual node rendering.</span></div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"></div><div class="line">    <span class="comment">// Find the empty scene node that is the parent of the specified node</span></div><div class="line">    scene::ISceneNode * findZone(scene::ISceneNode * node)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (!node)</div><div class="line">            <span class="keywordflow">return</span> 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (node-&gt;getType() == scene::ESNT_EMPTY)</div><div class="line">            <span class="keywordflow">return</span> node;</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> findZone(node-&gt;getParent());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Turn on all lights that are children (directly or indirectly) of the</span></div><div class="line">    <span class="comment">// specified scene node.</span></div><div class="line">    <span class="keywordtype">void</span> turnOnZoneLights(scene::ISceneNode * node)</div><div class="line">    {</div><div class="line">        core::list&lt;scene::ISceneNode*&gt; <span class="keyword">const</span> &amp; children = node-&gt;getChildren();</div><div class="line">        <span class="keywordflow">for</span> (core::list&lt;scene::ISceneNode*&gt;::ConstIterator child = children.begin();</div><div class="line">            child != children.end(); ++child)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> ((*child)-&gt;getType() == scene::ESNT_LIGHT)</div><div class="line">                (*child)-&gt;setVisible(<span class="keyword">true</span>);</div><div class="line">            <span class="keywordflow">else</span> <span class="comment">// Assume that lights don&#39;t have any children that are also lights</span></div><div class="line">                turnOnZoneLights(*child);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// A utility class to aid in sorting scene nodes into a distance order</span></div><div class="line">    <span class="keyword">class </span>LightDistanceElement</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        LightDistanceElement() {};</div><div class="line"></div><div class="line">        LightDistanceElement(scene::ISceneNode* n, f64 d)</div><div class="line">            : node(n), distance(d) { }</div><div class="line"></div><div class="line">        scene::ISceneNode* node;</div><div class="line">        f64 distance;</div><div class="line"></div><div class="line">        <span class="comment">// Lower distance elements are sorted to the start of the array</span></div><div class="line">        <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> LightDistanceElement&amp; other)<span class="keyword"> const</span></div><div class="line"><span class="keyword">        </span>{</div><div class="line">            <span class="keywordflow">return</span> (distance &lt; other.distance);</div><div class="line">        }</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argumentCount, <span class="keywordtype">char</span> * argumentValues[])</div><div class="line">{</div><div class="line">    <span class="comment">// ask user for driver</span></div><div class="line">    video::E_DRIVER_TYPE driverType=driverChoiceConsole();</div><div class="line">    <span class="keywordflow">if</span> (driverType==video::EDT_COUNT)</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line"></div><div class="line">    IrrlichtDevice *device = createDevice(driverType,</div><div class="line">            dimension2d&lt;u32&gt;(640, 480), 32);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(!device)</div><div class="line">        <span class="keywordflow">return</span> -1;</div><div class="line"></div><div class="line">    f32 <span class="keyword">const</span> lightRadius = 60.f; <span class="comment">// Enough to reach the far side of each &#39;zone&#39;</span></div><div class="line"></div><div class="line">    video::IVideoDriver* driver = device-&gt;getVideoDriver();</div><div class="line">    scene::ISceneManager* smgr = device-&gt;getSceneManager();</div><div class="line">    gui::IGUIEnvironment* guienv = device-&gt;getGUIEnvironment();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> io::path mediaPath = getExampleMediaPath();</div><div class="line"></div><div class="line">    gui::IGUISkin* skin = guienv-&gt;getSkin();</div><div class="line">    <span class="keywordflow">if</span> (skin)</div><div class="line">    {</div><div class="line">        skin-&gt;setColor(gui::EGDC_BUTTON_TEXT, video::SColor(255, 255, 255, 255));</div><div class="line">        gui::IGUIFont* font = guienv-&gt;getFont(mediaPath + <span class="stringliteral">&quot;fontlucida.png&quot;</span>);</div><div class="line">        <span class="keywordflow">if</span>(font)</div><div class="line">            skin-&gt;setFont(font);</div><div class="line">    }</div><div class="line"></div><div class="line">    guienv-&gt;addStaticText(L<span class="stringliteral">&quot;1 - No light management&quot;</span>, core::rect&lt;s32&gt;(10,10,200,30));</div><div class="line">    guienv-&gt;addStaticText(L<span class="stringliteral">&quot;2 - Closest 3 lights&quot;</span>, core::rect&lt;s32&gt;(10,30,200,50));</div><div class="line">    guienv-&gt;addStaticText(L<span class="stringliteral">&quot;3 - Lights in zone&quot;</span>, core::rect&lt;s32&gt;(10,50,200,70));</div></div><!-- fragment --><p> Add several "zones". You could use this technique to light individual rooms, for example. </p><div class="fragment"><div class="line">    <span class="keywordflow">for</span>(f32 zoneX = -100.f; zoneX &lt;= 100.f; zoneX += 50.f)</div><div class="line">        <span class="keywordflow">for</span>(f32 zoneY = -60.f; zoneY &lt;= 60.f; zoneY += 60.f)</div><div class="line">        {</div><div class="line">            <span class="comment">// Start with an empty scene node, which we will use to represent a zone.</span></div><div class="line">            scene::ISceneNode * zoneRoot = smgr-&gt;addEmptySceneNode();</div><div class="line">            zoneRoot-&gt;setPosition(vector3df(zoneX, zoneY, 0));</div><div class="line"></div><div class="line">            <span class="comment">// Each zone contains a rotating cube</span></div><div class="line">            scene::IMeshSceneNode * node = smgr-&gt;addCubeSceneNode(15, zoneRoot);</div><div class="line">            scene::ISceneNodeAnimator * rotation = smgr-&gt;createRotationAnimator(vector3df(0.25f, 0.5f, 0.75f));</div><div class="line">            node-&gt;addAnimator(rotation);</div><div class="line">            rotation-&gt;drop();</div><div class="line"></div><div class="line">            <span class="comment">// And each cube has three lights attached to it.  The lights are attached to billboards so</span></div><div class="line">            <span class="comment">// that we can see where they are.  The billboards are attached to the cube, so that the</span></div><div class="line">            <span class="comment">// lights are indirect descendents of the same empty scene node as the cube.</span></div><div class="line">            scene::IBillboardSceneNode * billboard = smgr-&gt;addBillboardSceneNode(node);</div><div class="line">            billboard-&gt;setPosition(vector3df(0, -14, 30));</div><div class="line">            billboard-&gt;setMaterialType(video::EMT_TRANSPARENT_ADD_COLOR );</div><div class="line">            billboard-&gt;setMaterialTexture(0, driver-&gt;getTexture(mediaPath + <span class="stringliteral">&quot;particle.bmp&quot;</span>));</div><div class="line">            billboard-&gt;setMaterialFlag(video::EMF_LIGHTING, <span class="keyword">false</span>);</div><div class="line">            smgr-&gt;addLightSceneNode(billboard, vector3df(0, 0, 0), video::SColorf(1, 0, 0), lightRadius);</div><div class="line"></div><div class="line">            billboard = smgr-&gt;addBillboardSceneNode(node);</div><div class="line">            billboard-&gt;setPosition(vector3df(-21, -14, -21));</div><div class="line">            billboard-&gt;setMaterialType(video::EMT_TRANSPARENT_ADD_COLOR );</div><div class="line">            billboard-&gt;setMaterialTexture(0, driver-&gt;getTexture(mediaPath + <span class="stringliteral">&quot;particle.bmp&quot;</span>));</div><div class="line">            billboard-&gt;setMaterialFlag(video::EMF_LIGHTING, <span class="keyword">false</span>);</div><div class="line">            smgr-&gt;addLightSceneNode(billboard, vector3df(0, 0, 0), video::SColorf(0, 1, 0), lightRadius);</div><div class="line"></div><div class="line">            billboard = smgr-&gt;addBillboardSceneNode(node);</div><div class="line">            billboard-&gt;setPosition(vector3df(21, -14, -21));</div><div class="line">            billboard-&gt;setMaterialType(video::EMT_TRANSPARENT_ADD_COLOR );</div><div class="line">            billboard-&gt;setMaterialTexture(0, driver-&gt;getTexture(mediaPath + <span class="stringliteral">&quot;particle.bmp&quot;</span>));</div><div class="line">            billboard-&gt;setMaterialFlag(video::EMF_LIGHTING, <span class="keyword">false</span>);</div><div class="line">            smgr-&gt;addLightSceneNode(billboard, vector3df(0, 0, 0), video::SColorf(0, 0, 1), lightRadius);</div><div class="line"></div><div class="line">            <span class="comment">// Each cube also has a smaller cube rotating around it, to show that the cubes are being</span></div><div class="line">            <span class="comment">// lit by the lights in their &#39;zone&#39;, not just lights that are their direct children.</span></div><div class="line">            node = smgr-&gt;addCubeSceneNode(5, node);</div><div class="line">            node-&gt;setPosition(vector3df(0, 21, 0));</div><div class="line">        }</div><div class="line"></div><div class="line">    smgr-&gt;addCameraSceneNode(0, vector3df(0,0,-130), vector3df(0,0,0));</div><div class="line"></div><div class="line">    CMyLightManager * myLightManager = <span class="keyword">new</span> CMyLightManager(smgr);</div><div class="line">    smgr-&gt;setLightManager(0); <span class="comment">// This is the default: we won&#39;t do light management until told to do it.</span></div><div class="line">    device-&gt;setEventReceiver(myLightManager);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> lastFps = -1;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(device-&gt;run())</div><div class="line">    {</div><div class="line">        driver-&gt;beginScene(video::ECBF_COLOR | video::ECBF_DEPTH, video::SColor(255,100,101,140));</div><div class="line">        smgr-&gt;drawAll();</div><div class="line">        guienv-&gt;drawAll();</div><div class="line">        driver-&gt;endScene();</div><div class="line"></div><div class="line">        <span class="keywordtype">int</span> fps = driver-&gt;getFPS();</div><div class="line">        <span class="keywordflow">if</span>(fps != lastFps)</div><div class="line">        {</div><div class="line">            lastFps = fps;</div><div class="line">            core::stringw str = L<span class="stringliteral">&quot;Managed Lights [&quot;</span>;</div><div class="line">            str += driver-&gt;getName();</div><div class="line">            str += <span class="stringliteral">&quot;] FPS:&quot;</span>;</div><div class="line">            str += fps;</div><div class="line">            device-&gt;setWindowCaption(str.c_str());</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    myLightManager-&gt;drop(); <span class="comment">// Drop my implicit reference</span></div><div class="line">    device-&gt;drop();</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<p>&nbsp;</p>
</body>
</html>
