<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tutorial 22: Material Viewer</title>
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Wanted to avoid copying .css to each folder, so copied default .css from doxyen in here, kicked out most stuff we don't need for examples and modified some a little bit. 
     Target was having a single html in each example folder which is created from the main.cpp files and needs no files besides some images below media folder.
     Feel free to improve :)
	 -->
<style>
body, table, div, p, dl {
	font: 400 14px/22px;
}
body {
	background-color: #F0F0F0;
	color: black;
	margin-left: 5%;
	margin-right: 5%;
}
p.reference, p.definition {
	font: 400 14px/22px;
}
.title {
	font: 400 14px/28px;
	font-size: 150%;
	font-weight: bold;
	margin: 10px 2px;
}
h1, h2, h3, h4, h5, h6 {
	-webkit-transition: text-shadow 0.5s linear;
	-moz-transition: text-shadow 0.5s linear;
	-ms-transition: text-shadow 0.5s linear;
	-o-transition: text-shadow 0.5s linear;
	transition: text-shadow 0.5s linear;
	margin-right: 15px;
}
caption {
	font-weight: bold;
}
h3.version {
	font-size: 90%;
	text-align: center;
}
a {
	color: #3D578C;
	font-weight: normal;
	text-decoration: none;
}
.contents a:visited {
	color: #4665A2;
}
a:hover {
	text-decoration: underline;
}
a.el {
	font-weight: bold;
}
a.code, a.code:visited, a.line, a.line:visited {
	color: #4665A2; 
}
a.codeRef, a.codeRef:visited, a.lineRef, a.lineRef:visited {
	color: #4665A2; 
}
pre.fragment {
	border: 1px solid #C4CFE5;
	background-color: #FBFCFD;
	padding: 4px 6px;
	margin: 4px 8px 4px 2px;
	overflow: auto;
	word-wrap: break-word;
	font-size:  9pt;
	line-height: 125%;
	font-family: monospace, fixed;
	font-size: 105%;
}
div.fragment {
	padding: 0px;
	margin: 4px 8px 4px 2px;
	background-color: #FBFCFD;
	border: 1px solid #C4CFE5;
}
div.line {
	font-family: monospace, fixed;
	font-size: 13px;
	min-height: 13px;
	line-height: 1.0;
	text-wrap: unrestricted;
	white-space: -moz-pre-wrap; /* Moz */
	white-space: -pre-wrap;     /* Opera 4-6 */
	white-space: -o-pre-wrap;   /* Opera 7 */
	white-space: pre-wrap;      /* CSS3  */
	word-wrap: break-word;      /* IE 5.5+ */
	text-indent: -53px;
	padding-left: 53px;
	padding-bottom: 0px;
	margin: 0px;
	-webkit-transition-property: background-color, box-shadow;
	-webkit-transition-duration: 0.5s;
	-moz-transition-property: background-color, box-shadow;
	-moz-transition-duration: 0.5s;
	-ms-transition-property: background-color, box-shadow;
	-ms-transition-duration: 0.5s;
	-o-transition-property: background-color, box-shadow;
	-o-transition-duration: 0.5s;
	transition-property: background-color, box-shadow;
	transition-duration: 0.5s;
}
div.contents {
	margin-top: 10px;
	margin-left: 12px;
	margin-right: 8px;
}
div.center {
	text-align: center;
	margin-top: 0px;
	margin-bottom: 0px;
	padding: 0px;
}
div.center img {
	border: 0px;
}
span.keyword {
	color: #008000
}
span.keywordtype {
	color: #604020
}
span.keywordflow {
	color: #e08000
}
span.comment {
	color: #800000
}
span.preprocessor {
	color: #806020
}
span.stringliteral {
	color: #002080
}
span.charliteral {
	color: #008080
}
blockquote {
	background-color: #F7F8FB;
	border-left: 2px solid #9CAFD4;
	margin: 0 24px 0 4px;
	padding: 0 12px 0 16px;
}
hr {
	height: 0px;
	border: none;
	border-top: 1px solid #4A6AAA;
}
address {
	font-style: normal;
	color: #2A3D61;
}
div.header {
	background-image:url('nav_h.png');
	background-repeat:repeat-x;
	background-color: #F9FAFC;
	margin:  0px;
	border-bottom: 1px solid #C4CFE5;
}
div.headertitle {
	padding: 5px 5px 5px 10px;
}
.image {
	text-align: center;
}
.caption {
	font-weight: bold;
}
div.zoom {
	border: 1px solid #90A5CE;
}
tr.heading h2 {
	margin-top: 12px;
	margin-bottom: 4px;
}
</style>
</head>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!--END TITLEAREA-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 22: Material Viewer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="../../media/example_screenshots/022shot.jpg" alt="022shot.jpg"/>
</div>
 <p>This example can be used to play around with material settings and watch the results. Only the default non-shader materials are used in here.</p>
<p>You have a node with a mesh, one dynamic light and global ambient light to play around with. You can move the light with cursor-keys and +/-. You can move the camera while left-mouse button is clicked. </p><div class="fragment"><div class="line"><span class="comment">// TODO: Should be possible to set all material values by the GUI.</span></div><div class="line"><span class="comment">//       For now just change the defaultMaterial in CApp::init for the rest.</span></div><div class="line"><span class="comment">// TODO: Allow users to switch between a sphere and a box mesh.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;irrlicht.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;driverChoice.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;exampleHelper.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;main.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>irr;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef _MSC_VER</span></div><div class="line"><span class="preprocessor">#pragma comment(lib, &quot;Irrlicht.lib&quot;)</span></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p> Variables within the empty namespace are globals which are restricted to this file. </p><div class="fragment"><div class="line"><span class="keyword">namespace</span></div><div class="line">{</div><div class="line">    <span class="comment">// For the gui id&#39;s</span></div><div class="line">    <span class="keyword">enum</span> EGUI_IDS</div><div class="line">    {</div><div class="line">        GUI_ID_OPEN_TEXTURE = 1,</div><div class="line">        GUI_ID_QUIT,</div><div class="line">        GUI_ID_MAX</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// Name used in texture selection to clear the textures on the node</span></div><div class="line">    <span class="keyword">const</span> core::stringw CLEAR_TEXTURE = L<span class="stringliteral">&quot;CLEAR texture&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">// some useful color constants</span></div><div class="line">    <span class="keyword">const</span> video::SColor SCOL_BLACK     = video::SColor(255, 0,   0,   0);</div><div class="line">    <span class="keyword">const</span> video::SColor SCOL_BLUE      = video::SColor(255, 0,   0,  255);</div><div class="line">    <span class="keyword">const</span> video::SColor SCOL_CYAN      = video::SColor(255, 0,  255, 255);</div><div class="line">    <span class="keyword">const</span> video::SColor SCOL_GRAY      = video::SColor(255, 128,128, 128);</div><div class="line">    <span class="keyword">const</span> video::SColor SCOL_GREEN     = video::SColor(255, 0,  255,  0);</div><div class="line">    <span class="keyword">const</span> video::SColor SCOL_MAGENTA   = video::SColor(255, 255, 0,  255);</div><div class="line">    <span class="keyword">const</span> video::SColor SCOL_RED       = video::SColor(255, 255, 0,   0);</div><div class="line">    <span class="keyword">const</span> video::SColor SCOL_YELLOW    = video::SColor(255, 255, 255, 0);</div><div class="line">    <span class="keyword">const</span> video::SColor SCOL_WHITE     = video::SColor(255, 255, 255, 255);</div><div class="line">};  <span class="comment">// namespace</span></div></div><!-- fragment --><p> Returns a new unique number on each call. </p><div class="fragment"><div class="line">s32 makeUniqueId()</div><div class="line">{</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> unique = GUI_ID_MAX;</div><div class="line">    ++unique;</div><div class="line">    <span class="keywordflow">return</span> unique;</div><div class="line">}</div></div><!-- fragment --><p> Find out which vertex-type is needed for the given material type. </p><div class="fragment"><div class="line">video::E_VERTEX_TYPE getVertexTypeForMaterialType(video::E_MATERIAL_TYPE materialType)</div><div class="line">{</div><div class="line">    <span class="keyword">using namespace </span>video;</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> ( materialType )</div><div class="line">    {</div><div class="line">        <span class="keywordflow">case</span> EMT_SOLID:</div><div class="line">            <span class="keywordflow">return</span> EVT_STANDARD;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> EMT_SOLID_2_LAYER:</div><div class="line">            <span class="keywordflow">return</span> EVT_STANDARD;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> EMT_LIGHTMAP:</div><div class="line">        <span class="keywordflow">case</span> EMT_LIGHTMAP_ADD:</div><div class="line">        <span class="keywordflow">case</span> EMT_LIGHTMAP_M2:</div><div class="line">        <span class="keywordflow">case</span> EMT_LIGHTMAP_M4:</div><div class="line">        <span class="keywordflow">case</span> EMT_LIGHTMAP_LIGHTING:</div><div class="line">        <span class="keywordflow">case</span> EMT_LIGHTMAP_LIGHTING_M2:</div><div class="line">        <span class="keywordflow">case</span> EMT_LIGHTMAP_LIGHTING_M4:</div><div class="line">            <span class="keywordflow">return</span> EVT_2TCOORDS;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> EMT_DETAIL_MAP:</div><div class="line">            <span class="keywordflow">return</span> EVT_2TCOORDS;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> EMT_SPHERE_MAP:</div><div class="line">            <span class="keywordflow">return</span> EVT_STANDARD;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> EMT_REFLECTION_2_LAYER:</div><div class="line">            <span class="keywordflow">return</span> EVT_2TCOORDS;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> EMT_TRANSPARENT_ADD_COLOR:</div><div class="line">            <span class="keywordflow">return</span> EVT_STANDARD;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> EMT_TRANSPARENT_ALPHA_CHANNEL:</div><div class="line">            <span class="keywordflow">return</span> EVT_STANDARD;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> EMT_TRANSPARENT_ALPHA_CHANNEL_REF:</div><div class="line">            <span class="keywordflow">return</span> EVT_STANDARD;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> EMT_TRANSPARENT_VERTEX_ALPHA:</div><div class="line">            <span class="keywordflow">return</span> EVT_STANDARD;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> EMT_TRANSPARENT_REFLECTION_2_LAYER:</div><div class="line">            <span class="keywordflow">return</span> EVT_2TCOORDS;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> EMT_NORMAL_MAP_SOLID:</div><div class="line">        <span class="keywordflow">case</span> EMT_NORMAL_MAP_TRANSPARENT_ADD_COLOR:</div><div class="line">        <span class="keywordflow">case</span> EMT_NORMAL_MAP_TRANSPARENT_VERTEX_ALPHA:</div><div class="line">        <span class="keywordflow">case</span> EMT_PARALLAX_MAP_SOLID:</div><div class="line">        <span class="keywordflow">case</span> EMT_PARALLAX_MAP_TRANSPARENT_ADD_COLOR:</div><div class="line">        <span class="keywordflow">case</span> EMT_PARALLAX_MAP_TRANSPARENT_VERTEX_ALPHA:</div><div class="line">            <span class="keywordflow">return</span> EVT_TANGENTS;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> EMT_ONETEXTURE_BLEND:</div><div class="line">            <span class="keywordflow">return</span> EVT_STANDARD;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> EMT_FORCE_32BIT:</div><div class="line">            <span class="keywordflow">return</span> EVT_STANDARD;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> EVT_STANDARD;</div><div class="line">}</div></div><!-- fragment --><p> Custom GUI-control to edit colorvalues. </p><div class="fragment"><div class="line"><span class="comment">// Constructor</span></div><div class="line">CColorControl::CColorControl(gui::IGUIEnvironment* guiEnv, <span class="keyword">const</span> core::position2d&lt;s32&gt; &amp; pos, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> *text, IGUIElement* parent, s32 <span class="keywordtype">id</span>)</div><div class="line">    : gui::IGUIElement(gui::EGUIET_ELEMENT, guiEnv, parent,id, core::rect&lt; s32 &gt;(pos, pos+core::dimension2d&lt;s32&gt;(80, 75)))</div><div class="line">    , DirtyFlag(true)</div><div class="line">    , Color(0)</div><div class="line">    , ColorStatic(0)</div><div class="line">    , EditAlpha(0)</div><div class="line">    , EditRed(0)</div><div class="line">    , EditGreen(0)</div><div class="line">    , EditBlue(0)</div><div class="line">{</div><div class="line">    <span class="keyword">using namespace </span>gui;</div><div class="line">    ButtonSetId = makeUniqueId();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> core::rect&lt; s32 &gt; rectControls(0,0,AbsoluteRect.getWidth(),AbsoluteRect.getHeight() );</div><div class="line">    IGUIStaticText * groupElement = guiEnv-&gt;addStaticText (L<span class="stringliteral">&quot;&quot;</span>, rectControls, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">this</span>, -1, <span class="keyword">false</span>);</div><div class="line">    groupElement-&gt;setNotClipped(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    guiEnv-&gt;addStaticText (text, core::rect&lt;s32&gt;(0,0,80,15), <span class="keyword">false</span>, <span class="keyword">false</span>, groupElement, -1, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    EditAlpha = addEditForNumbers(guiEnv, core::position2d&lt;s32&gt;(0,15), L<span class="stringliteral">&quot;a&quot;</span>, -1, groupElement );</div><div class="line">    EditRed = addEditForNumbers(guiEnv, core::position2d&lt;s32&gt;(0,30), L<span class="stringliteral">&quot;r&quot;</span>, -1, groupElement );</div><div class="line">    EditGreen = addEditForNumbers(guiEnv, core::position2d&lt;s32&gt;(0,45), L<span class="stringliteral">&quot;g&quot;</span>, -1, groupElement );</div><div class="line">    EditBlue = addEditForNumbers(guiEnv, core::position2d&lt;s32&gt;(0,60), L<span class="stringliteral">&quot;b&quot;</span>, -1, groupElement );</div><div class="line"></div><div class="line">    ColorStatic = guiEnv-&gt;addStaticText (L<span class="stringliteral">&quot;&quot;</span>, core::rect&lt;s32&gt;(60,15,80,75), <span class="keyword">true</span>, <span class="keyword">false</span>, groupElement, -1, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    guiEnv-&gt;addButton (core::rect&lt;s32&gt;(60,35,80,50), groupElement, ButtonSetId, L<span class="stringliteral">&quot;set&quot;</span>);</div><div class="line">    setEditsFromColor(Color);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// event receiver</span></div><div class="line"><span class="keywordtype">bool</span> CColorControl::OnEvent(<span class="keyword">const</span> SEvent &amp;event)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> ( event.EventType != EET_GUI_EVENT )</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( event.GUIEvent.Caller-&gt;getID() == ButtonSetId &amp;&amp; <span class="keyword">event</span>.GUIEvent.EventType == gui::EGET_BUTTON_CLICKED )</div><div class="line">    {</div><div class="line">        Color = getColorFromEdits();</div><div class="line">        setEditsFromColor(Color);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// set the color values</span></div><div class="line"><span class="keywordtype">void</span> CColorControl::setColor(<span class="keyword">const</span> video::SColor&amp; col)</div><div class="line">{</div><div class="line">    DirtyFlag = <span class="keyword">true</span>;</div><div class="line">    Color = col;</div><div class="line">    setEditsFromColor(Color);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Add a staticbox for a description + an editbox so users can enter numbers</span></div><div class="line">gui::IGUIEditBox* CColorControl::addEditForNumbers(gui::IGUIEnvironment* guiEnv, <span class="keyword">const</span> core::position2d&lt;s32&gt; &amp; pos, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> *text, s32 <span class="keywordtype">id</span>, gui::IGUIElement * parent)</div><div class="line">{</div><div class="line">    <span class="keyword">using namespace </span>gui;</div><div class="line"></div><div class="line">    core::rect&lt; s32 &gt; rect(pos, pos+core::dimension2d&lt;s32&gt;(10, 15));</div><div class="line">    guiEnv-&gt;addStaticText (text, rect, <span class="keyword">false</span>, <span class="keyword">false</span>, parent, -1, <span class="keyword">false</span>);</div><div class="line">    rect += core::position2d&lt;s32&gt;( 20, 0 );</div><div class="line">    rect.LowerRightCorner.X += 20;</div><div class="line">    gui::IGUIEditBox* edit = guiEnv-&gt;addEditBox(L<span class="stringliteral">&quot;0&quot;</span>, rect, <span class="keyword">true</span>, parent, <span class="keywordtype">id</span>);</div><div class="line">    <span class="keywordflow">return</span> edit;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Get the color value from the editfields</span></div><div class="line">video::SColor CColorControl::getColorFromEdits()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    video::SColor col;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (EditAlpha)</div><div class="line">    {</div><div class="line">        u32 alpha = core::strtoul10(core::stringc(EditAlpha-&gt;getText()).c_str());</div><div class="line">        <span class="keywordflow">if</span> (alpha &gt; 255)</div><div class="line">            alpha = 255;</div><div class="line">        col.setAlpha(alpha);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (EditRed)</div><div class="line">    {</div><div class="line">        u32 red = core::strtoul10(core::stringc(EditRed-&gt;getText()).c_str());</div><div class="line">        <span class="keywordflow">if</span> (red &gt; 255)</div><div class="line">            red = 255;</div><div class="line">        col.setRed(red);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (EditGreen)</div><div class="line">    {</div><div class="line">        u32 green = core::strtoul10(core::stringc(EditGreen-&gt;getText()).c_str());</div><div class="line">        <span class="keywordflow">if</span> (green &gt; 255)</div><div class="line">            green = 255;</div><div class="line">        col.setGreen(green);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (EditBlue)</div><div class="line">    {</div><div class="line">        u32 blue = core::strtoul10(core::stringc(EditBlue-&gt;getText()).c_str());</div><div class="line">        <span class="keywordflow">if</span> (blue &gt; 255)</div><div class="line">            blue = 255;</div><div class="line">        col.setBlue(blue);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> col;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Fill the editfields with the value for the given color</span></div><div class="line"><span class="keywordtype">void</span> CColorControl::setEditsFromColor(video::SColor col)</div><div class="line">{</div><div class="line">    DirtyFlag = <span class="keyword">true</span>;</div><div class="line">    <span class="keywordflow">if</span> ( EditAlpha )</div><div class="line">        EditAlpha-&gt;setText( core::stringw(col.getAlpha()).c_str() );</div><div class="line">    <span class="keywordflow">if</span> ( EditRed )</div><div class="line">        EditRed-&gt;setText( core::stringw(col.getRed()).c_str() );</div><div class="line">    <span class="keywordflow">if</span> ( EditGreen )</div><div class="line">        EditGreen-&gt;setText( core::stringw(col.getGreen()).c_str() );</div><div class="line">    <span class="keywordflow">if</span> ( EditBlue )</div><div class="line">        EditBlue-&gt;setText( core::stringw(col.getBlue()).c_str() );</div><div class="line">    <span class="keywordflow">if</span> ( ColorStatic )</div><div class="line">        ColorStatic-&gt;setBackgroundColor(col);</div><div class="line">}</div></div><!-- fragment --><p> Custom GUI-control for to edit all colors typically used in materials and lights </p><div class="fragment"><div class="line"><span class="comment">// Constructor</span></div><div class="line">CTypicalColorsControl::CTypicalColorsControl(gui::IGUIEnvironment* guiEnv, <span class="keyword">const</span> core::position2d&lt;s32&gt; &amp; pos, <span class="keywordtype">bool</span> hasEmissive, IGUIElement* parent, s32 <span class="keywordtype">id</span>)</div><div class="line">    : gui::IGUIElement(gui::EGUIET_ELEMENT, guiEnv, parent,id, core::rect&lt;s32&gt;(pos,pos+core::dimension2d&lt;s32&gt;(60,250)))</div><div class="line">    , ControlAmbientColor(0), ControlDiffuseColor(0), ControlSpecularColor(0), ControlEmissiveColor(0)</div><div class="line">{</div><div class="line">    ControlAmbientColor = <span class="keyword">new</span> CColorControl( guiEnv, core::position2d&lt;s32&gt;(0, 0), L<span class="stringliteral">&quot;Ambient&quot;</span>, <span class="keyword">this</span>);</div><div class="line">    ControlDiffuseColor = <span class="keyword">new</span> CColorControl( guiEnv, core::position2d&lt;s32&gt;(0, 75), L<span class="stringliteral">&quot;Diffuse&quot;</span>, <span class="keyword">this</span> );</div><div class="line">    ControlSpecularColor = <span class="keyword">new</span> CColorControl( guiEnv, core::position2d&lt;s32&gt;(0, 150), L<span class="stringliteral">&quot;Specular&quot;</span>, <span class="keyword">this</span> );</div><div class="line">    <span class="keywordflow">if</span> ( hasEmissive )</div><div class="line">    {</div><div class="line">        ControlEmissiveColor = <span class="keyword">new</span> CColorControl( guiEnv, core::position2d&lt;s32&gt;(0, 225), L<span class="stringliteral">&quot;Emissive&quot;</span>, <span class="keyword">this</span> );</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Destructor</span></div><div class="line">CTypicalColorsControl::~CTypicalColorsControl()</div><div class="line">{</div><div class="line">    ControlAmbientColor-&gt;drop();</div><div class="line">    ControlDiffuseColor-&gt;drop();</div><div class="line">    <span class="keywordflow">if</span> ( ControlEmissiveColor )</div><div class="line">        ControlEmissiveColor-&gt;drop();</div><div class="line">    ControlSpecularColor-&gt;drop();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Set the color values to those within the material</span></div><div class="line"><span class="keywordtype">void</span> CTypicalColorsControl::setColorsToMaterialColors(<span class="keyword">const</span> video::SMaterial &amp; material)</div><div class="line">{</div><div class="line">    ControlAmbientColor-&gt;setColor(material.AmbientColor);</div><div class="line">    ControlDiffuseColor-&gt;setColor(material.DiffuseColor);</div><div class="line">    ControlEmissiveColor-&gt;setColor(material.EmissiveColor);</div><div class="line">    ControlSpecularColor-&gt;setColor(material.SpecularColor);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Update all changed colors in the material</span></div><div class="line"><span class="keywordtype">void</span> CTypicalColorsControl::updateMaterialColors(video::SMaterial &amp; material)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="keywordflow">if</span> ( ControlAmbientColor-&gt;isDirty() )</div><div class="line">        material.AmbientColor = ControlAmbientColor-&gt;getColor();</div><div class="line">    <span class="keywordflow">if</span> ( ControlDiffuseColor-&gt;isDirty() )</div><div class="line">        material.DiffuseColor = ControlDiffuseColor-&gt;getColor();</div><div class="line">    <span class="keywordflow">if</span> ( ControlEmissiveColor-&gt;isDirty() )</div><div class="line">        material.EmissiveColor = ControlEmissiveColor-&gt;getColor();</div><div class="line">    <span class="keywordflow">if</span> ( ControlSpecularColor-&gt;isDirty() )</div><div class="line">        material.SpecularColor = ControlSpecularColor-&gt;getColor();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Set the color values to those from the light data</span></div><div class="line"><span class="keywordtype">void</span> CTypicalColorsControl::setColorsToLightDataColors(<span class="keyword">const</span> video::SLight &amp; lightData)</div><div class="line">{</div><div class="line">    ControlAmbientColor-&gt;setColor(lightData.AmbientColor.toSColor());</div><div class="line">    ControlDiffuseColor-&gt;setColor(lightData.DiffuseColor.toSColor());</div><div class="line">    ControlSpecularColor-&gt;setColor(lightData.SpecularColor.toSColor());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Update all changed colors in the light data</span></div><div class="line"><span class="keywordtype">void</span> CTypicalColorsControl::updateLightColors(video::SLight &amp; lightData)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="keywordflow">if</span> ( ControlAmbientColor-&gt;isDirty() )</div><div class="line">        lightData.AmbientColor = video::SColorf( ControlAmbientColor-&gt;getColor() );</div><div class="line">    <span class="keywordflow">if</span> ( ControlDiffuseColor-&gt;isDirty() )</div><div class="line">        lightData.DiffuseColor = video::SColorf( ControlDiffuseColor-&gt;getColor() );</div><div class="line">    <span class="keywordflow">if</span> ( ControlSpecularColor-&gt;isDirty() )</div><div class="line">        lightData.SpecularColor = video::SColorf(ControlSpecularColor-&gt;getColor() );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// To reset the dirty flags</span></div><div class="line"><span class="keywordtype">void</span> CTypicalColorsControl::resetDirty()</div><div class="line">{</div><div class="line">    ControlAmbientColor-&gt;resetDirty();</div><div class="line">    ControlDiffuseColor-&gt;resetDirty();</div><div class="line">    ControlSpecularColor-&gt;resetDirty();</div><div class="line">    <span class="keywordflow">if</span> ( ControlEmissiveColor )</div><div class="line">        ControlEmissiveColor-&gt;resetDirty();</div><div class="line">}</div></div><!-- fragment --><p> GUI-Control to offer a selection of available textures. </p><div class="fragment"><div class="line">CTextureControl::CTextureControl(gui::IGUIEnvironment* guiEnv, video::IVideoDriver * driver, <span class="keyword">const</span> core::position2d&lt;s32&gt; &amp; pos, IGUIElement* parent, s32 <span class="keywordtype">id</span>)</div><div class="line">: gui::IGUIElement(gui::EGUIET_ELEMENT, guiEnv, parent,id, core::rect&lt;s32&gt;(pos,pos+core::dimension2d&lt;s32&gt;(150,15)))</div><div class="line">, DirtyFlag(true), ComboTexture(0)</div><div class="line">{</div><div class="line">    core::rect&lt;s32&gt; rectCombo(0, 0, AbsoluteRect.getWidth(),AbsoluteRect.getHeight());</div><div class="line">    ComboTexture = guiEnv-&gt;addComboBox (rectCombo, <span class="keyword">this</span>);</div><div class="line">    updateTextures(driver);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> CTextureControl::OnEvent(<span class="keyword">const</span> SEvent &amp;event)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> ( event.EventType != EET_GUI_EVENT )</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( event.GUIEvent.Caller == ComboTexture &amp;&amp; event.GUIEvent.EventType == gui::EGET_COMBO_BOX_CHANGED )</div><div class="line">    {</div><div class="line">        DirtyFlag = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Workaround for a problem with comboboxes.</span></div><div class="line"><span class="comment">// We have to get in front when the combobox wants to get in front or combobox-list might be drawn below other elements.</span></div><div class="line"><span class="keywordtype">bool</span> CTextureControl::bringToFront(IGUIElement* element)</div><div class="line">{</div><div class="line">    <span class="keywordtype">bool</span> result = gui::IGUIElement::bringToFront(element);</div><div class="line">    <span class="keywordflow">if</span> ( Parent &amp;&amp; element == ComboTexture )</div><div class="line">        result &amp;= Parent-&gt;bringToFront(<span class="keyword">this</span>);</div><div class="line">    <span class="keywordflow">return</span> result;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// return selected texturename (if any, otherwise 0)</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">wchar_t</span> * CTextureControl::getSelectedTextureName()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    s32 selected = ComboTexture-&gt;getSelected();</div><div class="line">    <span class="keywordflow">if</span> ( selected &lt; 0 )</div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    <span class="keywordflow">return</span> ComboTexture-&gt;getItem(selected);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> CTextureControl::selectTextureByName(<span class="keyword">const</span> irr::core::stringw&amp; name)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (u32 i=0; i&lt; ComboTexture-&gt;getItemCount(); ++i)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> ( name == ComboTexture-&gt;getItem(i))</div><div class="line">        {</div><div class="line">            ComboTexture-&gt;setSelected(i);</div><div class="line">            DirtyFlag = <span class="keyword">true</span>;</div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Put the names of all currently loaded textures in a combobox</span></div><div class="line"><span class="keywordtype">void</span> CTextureControl::updateTextures(video::IVideoDriver * driver)</div><div class="line">{</div><div class="line">    s32 oldSelected = ComboTexture-&gt;getSelected();</div><div class="line">    s32 selectNew = -1;</div><div class="line">    core::stringw oldTextureName;</div><div class="line">    <span class="keywordflow">if</span> ( oldSelected &gt;= 0 )</div><div class="line">    {</div><div class="line">        oldTextureName = ComboTexture-&gt;getItem(oldSelected);</div><div class="line">    }</div><div class="line">    ComboTexture-&gt;clear();</div><div class="line">    <span class="keywordflow">for</span> ( u32 i=0; i &lt; driver-&gt;getTextureCount(); ++i )</div><div class="line">    {</div><div class="line">        video::ITexture * texture = driver-&gt;getTextureByIndex(i);</div><div class="line">        core::stringw name( texture-&gt;getName() );</div><div class="line">        ComboTexture-&gt;addItem( name.c_str() );</div><div class="line">        <span class="keywordflow">if</span> ( !oldTextureName.empty() &amp;&amp; selectNew &lt; 0 &amp;&amp; name == oldTextureName )</div><div class="line">            selectNew = i;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// add another name which can be used to clear the texture</span></div><div class="line">    ComboTexture-&gt;addItem( CLEAR_TEXTURE.c_str() );</div><div class="line">    <span class="keywordflow">if</span> ( CLEAR_TEXTURE == oldTextureName )</div><div class="line">        selectNew = ComboTexture-&gt;getItemCount()-1;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( selectNew &gt;= 0 )</div><div class="line">        ComboTexture-&gt;setSelected(selectNew);</div><div class="line"></div><div class="line">    DirtyFlag = <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> Control which allows setting some of the material values for a meshscenenode </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> CMaterialControl::init(scene::IMeshSceneNode* node, IrrlichtDevice * device, <span class="keyword">const</span> core::position2d&lt;s32&gt; &amp; pos, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> * description)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> ( Initialized || !node || !device) <span class="comment">// initializing twice or with invalid data not allowed</span></div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    Driver = device-&gt;getVideoDriver ();</div><div class="line">    gui::IGUIEnvironment* guiEnv = device-&gt;getGUIEnvironment();</div><div class="line">    <span class="comment">//scene::ISceneManager* smgr = device-&gt;getSceneManager();</span></div><div class="line">    <span class="keyword">const</span> video::SMaterial &amp; material = node-&gt;getMaterial(0);</div><div class="line"></div><div class="line">    s32 top = pos.Y;</div><div class="line"></div><div class="line">    <span class="comment">// Description</span></div><div class="line">    guiEnv-&gt;addStaticText(description, core::rect&lt;s32&gt;(pos.X, top, pos.X+60, top+15), <span class="keyword">false</span>, <span class="keyword">false</span>, 0, -1, <span class="keyword">false</span>);</div><div class="line">    top += 15;</div><div class="line"></div><div class="line">    <span class="comment">// Control for material type</span></div><div class="line">    core::rect&lt;s32&gt; rectCombo(pos.X, top, 150, top+15);</div><div class="line">    top += 15;</div><div class="line">    ComboMaterial = guiEnv-&gt;addComboBox (rectCombo);</div><div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=0; i &lt;= (int)video::EMT_ONETEXTURE_BLEND; ++i )</div><div class="line">    {</div><div class="line">        ComboMaterial-&gt;addItem( core::stringw(video::sBuiltInMaterialTypeNames[i]).c_str() );</div><div class="line">    }</div><div class="line">    ComboMaterial-&gt;setSelected( (s32)material.MaterialType );</div><div class="line"></div><div class="line">    <span class="comment">// Control to enable/disabling material lighting</span></div><div class="line">    core::rect&lt;s32&gt; rectBtn(core::position2d&lt;s32&gt;(pos.X, top), core::dimension2d&lt;s32&gt;(100, 15));</div><div class="line">    top += 15;</div><div class="line">    ButtonLighting = guiEnv-&gt;addButton (rectBtn, 0, -1, L<span class="stringliteral">&quot;Lighting&quot;</span>);</div><div class="line">    ButtonLighting-&gt;setIsPushButton(<span class="keyword">true</span>);</div><div class="line">    ButtonLighting-&gt;setPressed(material.Lighting);</div><div class="line">    core::rect&lt;s32&gt; rectInfo( rectBtn.LowerRightCorner.X, rectBtn.UpperLeftCorner.Y, rectBtn.LowerRightCorner.X+40, rectBtn.UpperLeftCorner.Y+15 );</div><div class="line">    InfoLighting = guiEnv-&gt;addStaticText(L<span class="stringliteral">&quot;&quot;</span>, rectInfo, <span class="keyword">true</span>, <span class="keyword">false</span> );</div><div class="line">    InfoLighting-&gt;setTextAlignment(gui::EGUIA_CENTER, gui::EGUIA_CENTER );</div><div class="line"></div><div class="line">    <span class="comment">// Controls for colors</span></div><div class="line">    TypicalColorsControl = <span class="keyword">new</span> CTypicalColorsControl(guiEnv, core::position2d&lt;s32&gt;(pos.X, top), <span class="keyword">true</span>, guiEnv-&gt;getRootGUIElement());</div><div class="line">    top += 300;</div><div class="line">    TypicalColorsControl-&gt;setColorsToMaterialColors(material);</div><div class="line"></div><div class="line">    <span class="comment">// Controls for selecting the material textures</span></div><div class="line">    guiEnv-&gt;addStaticText(L<span class="stringliteral">&quot;Textures&quot;</span>, core::rect&lt;s32&gt;(pos.X, top, pos.X+60, top+15), <span class="keyword">false</span>, <span class="keyword">false</span>, 0, -1, <span class="keyword">false</span>);</div><div class="line">    top += 15;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (irr::u32 i=0; i&lt;irr::video::MATERIAL_MAX_TEXTURES; ++i)</div><div class="line">    {</div><div class="line">        TextureControls[i] = <span class="keyword">new</span> CTextureControl(guiEnv, Driver, core::position2di(pos.X, top), guiEnv-&gt;getRootGUIElement());</div><div class="line">        top += 15;</div><div class="line">    }</div><div class="line"></div><div class="line">    Initialized = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> CMaterialControl::update(scene::IMeshSceneNode* sceneNode, scene::IMeshSceneNode* sceneNode2T, scene::IMeshSceneNode* sceneNodeTangents)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> ( !Initialized )</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    video::SMaterial &amp; material = sceneNode-&gt;getMaterial(0);</div><div class="line">    video::SMaterial &amp; material2T = sceneNode2T-&gt;getMaterial(0);</div><div class="line">    video::SMaterial &amp; materialTangents = sceneNodeTangents-&gt;getMaterial(0);</div><div class="line"></div><div class="line">    s32 selectedMaterial = ComboMaterial-&gt;getSelected();</div><div class="line">    <span class="keywordflow">if</span> ( selectedMaterial &gt;= (s32)video::EMT_SOLID &amp;&amp; selectedMaterial &lt;= (s32)video::EMT_ONETEXTURE_BLEND)</div><div class="line">    {</div><div class="line">        <span class="comment">// Show the node which has a mesh to work with the currently selected material</span></div><div class="line">        video::E_VERTEX_TYPE vertexType = getVertexTypeForMaterialType((video::E_MATERIAL_TYPE)selectedMaterial);</div><div class="line">        <span class="keywordflow">switch</span> ( vertexType )</div><div class="line">        {</div><div class="line">            <span class="keywordflow">case</span> video::EVT_STANDARD:</div><div class="line">                material.MaterialType = (video::E_MATERIAL_TYPE)selectedMaterial;</div><div class="line">                sceneNode-&gt;setVisible(<span class="keyword">true</span>);</div><div class="line">                sceneNode2T-&gt;setVisible(<span class="keyword">false</span>);</div><div class="line">                sceneNodeTangents-&gt;setVisible(<span class="keyword">false</span>);</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">case</span> video::EVT_2TCOORDS:</div><div class="line">                material2T.MaterialType = (video::E_MATERIAL_TYPE)selectedMaterial;</div><div class="line">                sceneNode-&gt;setVisible(<span class="keyword">false</span>);</div><div class="line">                sceneNode2T-&gt;setVisible(<span class="keyword">true</span>);</div><div class="line">                sceneNodeTangents-&gt;setVisible(<span class="keyword">false</span>);</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">case</span> video::EVT_TANGENTS:</div><div class="line">                materialTangents.MaterialType = (video::E_MATERIAL_TYPE)selectedMaterial;</div><div class="line">                sceneNode-&gt;setVisible(<span class="keyword">false</span>);</div><div class="line">                sceneNode2T-&gt;setVisible(<span class="keyword">false</span>);</div><div class="line">                sceneNodeTangents-&gt;setVisible(<span class="keyword">true</span>);</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Always update materials of all nodes, otherwise the tool is confusing to use.</span></div><div class="line">    updateMaterial(material);</div><div class="line">    updateMaterial(material2T);</div><div class="line">    updateMaterial(materialTangents);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( ButtonLighting-&gt;isPressed() )</div><div class="line">        InfoLighting-&gt;setText(L<span class="stringliteral">&quot;is on&quot;</span>);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        InfoLighting-&gt;setText(L<span class="stringliteral">&quot;is off&quot;</span>);</div><div class="line"></div><div class="line">    TypicalColorsControl-&gt;resetDirty();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (irr::u32 i=0; i&lt;irr::video::MATERIAL_MAX_TEXTURES; ++i)</div><div class="line">        TextureControls[i]-&gt;resetDirty();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> CMaterialControl::updateTextures()</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (irr::u32 i=0; i&lt;irr::video::MATERIAL_MAX_TEXTURES; ++i)</div><div class="line">        TextureControls[i]-&gt;updateTextures(Driver);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> CMaterialControl::selectTextures(<span class="keyword">const</span> irr::core::stringw&amp; name)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (irr::u32 i=0; i&lt;irr::video::MATERIAL_MAX_TEXTURES; ++i)</div><div class="line">        TextureControls[i]-&gt;selectTextureByName(name);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> CMaterialControl::isLightingEnabled()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="keywordflow">return</span> ButtonLighting &amp;&amp; ButtonLighting-&gt;isPressed();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> CMaterialControl::updateMaterial(video::SMaterial &amp; material)</div><div class="line">{</div><div class="line">    TypicalColorsControl-&gt;updateMaterialColors(material);</div><div class="line">    material.Lighting = ButtonLighting-&gt;isPressed();</div><div class="line">    <span class="keywordflow">for</span> (irr::u32 i=0; i&lt;irr::video::MATERIAL_MAX_TEXTURES; ++i)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> ( TextureControls[i]-&gt;isDirty() )</div><div class="line">        {</div><div class="line">            material.TextureLayer[i].Texture = Driver-&gt;getTexture( io::path(TextureControls[i]-&gt;getSelectedTextureName()) );</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Control to allow setting the color values of a lightscenenode. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> CLightNodeControl::init(scene::ILightSceneNode* node, gui::IGUIEnvironment* guiEnv, <span class="keyword">const</span> core::position2d&lt;s32&gt; &amp; pos, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> * description)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> ( Initialized || !node || !guiEnv) <span class="comment">// initializing twice or with invalid data not allowed</span></div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    guiEnv-&gt;addStaticText(description, core::rect&lt;s32&gt;(pos.X, pos.Y, pos.X+70, pos.Y+15), <span class="keyword">false</span>, <span class="keyword">false</span>, 0, -1, <span class="keyword">false</span>);</div><div class="line">    TypicalColorsControl = <span class="keyword">new</span> CTypicalColorsControl(guiEnv, core::position2d&lt;s32&gt;(pos.X, pos.Y+15), <span class="keyword">false</span>, guiEnv-&gt;getRootGUIElement());</div><div class="line">    <span class="keyword">const</span> video::SLight &amp; lightData = node-&gt;getLightData();</div><div class="line">    TypicalColorsControl-&gt;setColorsToLightDataColors(lightData);</div><div class="line">    Initialized = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> CLightNodeControl::update(scene::ILightSceneNode* node)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> ( !Initialized )</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    video::SLight &amp; lightData = node-&gt;getLightData();</div><div class="line">    TypicalColorsControl-&gt;updateLightColors(lightData);</div><div class="line">}</div></div><!-- fragment --><p> Main application class </p><div class="fragment"></div><!-- fragment --><p> Event handler </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> CApp::OnEvent(<span class="keyword">const</span> SEvent &amp;event)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (event.EventType == EET_GUI_EVENT)</div><div class="line">    {</div><div class="line">        gui::IGUIEnvironment* env = Device-&gt;getGUIEnvironment();</div><div class="line"></div><div class="line">        <span class="keywordflow">switch</span>(event.GUIEvent.EventType)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">case</span> gui::EGET_MENU_ITEM_SELECTED:</div><div class="line">            {</div><div class="line">                gui::IGUIContextMenu* menu = (gui::IGUIContextMenu*)event.GUIEvent.Caller;</div><div class="line">                s32 <span class="keywordtype">id</span> = menu-&gt;getItemCommandId(menu-&gt;getSelectedItem());</div><div class="line"></div><div class="line">                <span class="keywordflow">switch</span>(<span class="keywordtype">id</span>)</div><div class="line">                {</div><div class="line">                    <span class="keywordflow">case</span> GUI_ID_OPEN_TEXTURE: <span class="comment">// File -&gt; Open Texture</span></div><div class="line">                        env-&gt;addFileOpenDialog(L<span class="stringliteral">&quot;Please select a texture file to open&quot;</span>);</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                    <span class="keywordflow">case</span> GUI_ID_QUIT: <span class="comment">// File -&gt; Quit</span></div><div class="line">                        setRunning(<span class="keyword">false</span>);</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">case</span> gui::EGET_FILE_SELECTED:</div><div class="line">            {</div><div class="line">                <span class="comment">// load the model file, selected in the file open dialog</span></div><div class="line">                gui::IGUIFileOpenDialog* dialog =</div><div class="line">                    (gui::IGUIFileOpenDialog*)event.GUIEvent.Caller;</div><div class="line">                loadTexture(io::path(dialog-&gt;getFileName()).c_str());</div><div class="line">            }</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">default</span>:</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (event.EventType == EET_KEY_INPUT_EVENT)</div><div class="line">    {</div><div class="line">        KeysPressed[<span class="keyword">event</span>.KeyInput.Key] = <span class="keyword">event</span>.KeyInput.PressedDown;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (event.EventType == EET_MOUSE_INPUT_EVENT)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (!MousePressed &amp;&amp; event.MouseInput.isLeftPressed())</div><div class="line">        {</div><div class="line">            gui::IGUIEnvironment* guiEnv = Device-&gt;getGUIEnvironment();</div><div class="line">            <span class="keywordflow">if</span> ( guiEnv-&gt;getHovered() == guiEnv-&gt;getRootGUIElement() )  <span class="comment">// Click on background</span></div><div class="line">            {</div><div class="line">                MousePressed  = <span class="keyword">true</span>;</div><div class="line">                MouseStart.X = <span class="keyword">event</span>.MouseInput.X;</div><div class="line">                MouseStart.Y = <span class="keyword">event</span>.MouseInput.Y;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (MousePressed &amp;&amp; !event.MouseInput.isLeftPressed())</div><div class="line">        {</div><div class="line">            MousePressed = <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Application initialization</span></div><div class="line"><span class="comment">// returns true when it was successful initialized, otherwise false.</span></div><div class="line"><span class="keywordtype">bool</span> CApp::init(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">    <span class="comment">// ask user for driver</span></div><div class="line">    Config.DriverType=driverChoiceConsole();</div><div class="line">    <span class="keywordflow">if</span> (Config.DriverType==video::EDT_COUNT)</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// create the device with the settings from our config</span></div><div class="line">    Device = createDevice(Config.DriverType, Config.ScreenSize);</div><div class="line">    <span class="keywordflow">if</span> (!Device)</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    Device-&gt;setWindowCaption( core::stringw(video::DRIVER_TYPE_NAMES[Config.DriverType]).c_str() );</div><div class="line">    Device-&gt;setEventReceiver(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    scene::ISceneManager* smgr = Device-&gt;getSceneManager();</div><div class="line">    video::IVideoDriver * driver = Device-&gt;getVideoDriver ();</div><div class="line">    gui::IGUIEnvironment* guiEnv = Device-&gt;getGUIEnvironment();</div><div class="line">    MeshManipulator = smgr-&gt;getMeshManipulator();</div><div class="line"></div><div class="line">    <span class="comment">// set a nicer font</span></div><div class="line">    gui::IGUISkin* skin = guiEnv-&gt;getSkin();</div><div class="line">    gui::IGUIFont* font = guiEnv-&gt;getFont(getExampleMediaPath() + <span class="stringliteral">&quot;fonthaettenschweiler.bmp&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (font)</div><div class="line">        skin-&gt;setFont(font);</div><div class="line"></div><div class="line">    <span class="comment">// remove some alpha value because it makes those menus harder to read otherwise</span></div><div class="line">    video::SColor col3dHighLight( skin-&gt;getColor(gui::EGDC_APP_WORKSPACE) );</div><div class="line">    col3dHighLight.setAlpha(255);</div><div class="line">    video::SColor colHighLight( col3dHighLight );</div><div class="line">    skin-&gt;setColor(gui::EGDC_HIGH_LIGHT, colHighLight );</div><div class="line">    skin-&gt;setColor(gui::EGDC_3D_HIGH_LIGHT, col3dHighLight );</div><div class="line"></div><div class="line">    <span class="comment">// Add some textures which are useful to test material settings</span></div><div class="line">    createDefaultTextures(driver);</div><div class="line"></div><div class="line">    <span class="comment">// create a menu</span></div><div class="line">    gui::IGUIContextMenu * menuBar = guiEnv-&gt;addMenu();</div><div class="line">    menuBar-&gt;addItem(L<span class="stringliteral">&quot;File&quot;</span>, -1, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    gui::IGUIContextMenu* subMenuFile = menuBar-&gt;getSubMenu(0);</div><div class="line">    subMenuFile-&gt;addItem(L<span class="stringliteral">&quot;Open texture ...&quot;</span>, GUI_ID_OPEN_TEXTURE);</div><div class="line">    subMenuFile-&gt;addSeparator();</div><div class="line">    subMenuFile-&gt;addItem(L<span class="stringliteral">&quot;Quit&quot;</span>, GUI_ID_QUIT);</div><div class="line"></div><div class="line">    <span class="comment">// a static camera</span></div><div class="line">    Camera = smgr-&gt;addCameraSceneNode (0, core::vector3df(0, 40, -40),</div><div class="line">                                        core::vector3df(0, 10, 0),</div><div class="line">                                        -1);</div><div class="line"></div><div class="line">    <span class="comment">// default material</span></div><div class="line">    video::SMaterial defaultMaterial;</div><div class="line">    defaultMaterial.Shininess = 20.f;</div><div class="line"></div><div class="line">    <span class="comment">// add the nodes which are used to show the materials</span></div><div class="line">    SceneNode = smgr-&gt;addCubeSceneNode (30.0f, 0, -1,</div><div class="line">                                       core::vector3df(0, 0, 0),</div><div class="line">                                       core::vector3df(0.f, 45.f, 0.f),</div><div class="line">                                       core::vector3df(1.0f, 1.0f, 1.0f));</div><div class="line">    SceneNode-&gt;getMaterial(0) = defaultMaterial;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> s32 controlsTop = 20;</div><div class="line">    MeshMaterialControl = <span class="keyword">new</span> CMaterialControl();</div><div class="line">    MeshMaterialControl-&gt;init( SceneNode, Device, core::position2d&lt;s32&gt;(10,controlsTop), L<span class="stringliteral">&quot;Material&quot;</span> );</div><div class="line">    MeshMaterialControl-&gt;selectTextures(core::stringw(<span class="stringliteral">&quot;CARO_A8R8G8B8&quot;</span>));    <span class="comment">// set a useful default texture</span></div><div class="line"></div><div class="line">    <span class="comment">// create nodes with other vertex types</span></div><div class="line">    scene::IMesh * mesh2T = MeshManipulator-&gt;createMeshWith2TCoords(SceneNode-&gt;getMesh());</div><div class="line">    SceneNode2T = smgr-&gt;addMeshSceneNode(mesh2T, 0, -1, SceneNode-&gt;getPosition(), SceneNode-&gt;getRotation(), SceneNode-&gt;getScale() );</div><div class="line">    mesh2T-&gt;drop();</div><div class="line"></div><div class="line">    scene::IMesh * meshTangents = MeshManipulator-&gt;createMeshWithTangents(SceneNode-&gt;getMesh(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">    SceneNodeTangents = smgr-&gt;addMeshSceneNode(meshTangents, 0, -1</div><div class="line">                                        , SceneNode-&gt;getPosition(), SceneNode-&gt;getRotation(), SceneNode-&gt;getScale() );</div><div class="line">    meshTangents-&gt;drop();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// add one light</span></div><div class="line">    NodeLight = smgr-&gt;addLightSceneNode(0, core::vector3df(0, 0, -40),</div><div class="line">                                            video::SColorf(1.0f, 1.0f, 1.0f),</div><div class="line">                                            35.0f);</div><div class="line">    LightControl = <span class="keyword">new</span> CLightNodeControl();</div><div class="line">    LightControl-&gt;init(NodeLight, guiEnv, core::position2d&lt;s32&gt;(550,controlsTop), L<span class="stringliteral">&quot;Dynamic light&quot;</span> );</div><div class="line"></div><div class="line">    <span class="comment">// one large cube around everything. That&#39;s mainly to make the light more obvious.</span></div><div class="line">    scene::IMeshSceneNode* backgroundCube = smgr-&gt;addCubeSceneNode (200.0f, 0, -1, core::vector3df(0, 0, 0),</div><div class="line">                                       core::vector3df(45, 0, 0),</div><div class="line">                                       core::vector3df(1.0f, 1.0f, 1.0f));</div><div class="line">    backgroundCube-&gt;getMaterial(0).BackfaceCulling = <span class="keyword">false</span>;         <span class="comment">// we are within the cube, so we have to disable backface culling to see it</span></div><div class="line">    backgroundCube-&gt;getMaterial(0).EmissiveColor.set(255,50,50,50); <span class="comment">// we keep some self lighting to keep texts visible</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// Add a the mesh vertex color control</span></div><div class="line">    guiEnv-&gt;addStaticText(L<span class="stringliteral">&quot;Mesh&quot;</span>, core::rect&lt;s32&gt;(200, controlsTop, 270, controlsTop+15), <span class="keyword">false</span>, <span class="keyword">false</span>, 0, -1, <span class="keyword">false</span>);</div><div class="line">    ControlVertexColors = <span class="keyword">new</span> CColorControl( guiEnv, core::position2d&lt;s32&gt;(200, controlsTop+15), L<span class="stringliteral">&quot;Vertex colors&quot;</span>, guiEnv-&gt;getRootGUIElement());</div><div class="line">    video::S3DVertex * vertices =  (video::S3DVertex *)SceneNode-&gt;getMesh()-&gt;getMeshBuffer(0)-&gt;getVertices();</div><div class="line">    <span class="keywordflow">if</span> ( vertices )</div><div class="line">    {</div><div class="line">        ControlVertexColors-&gt;setColor(vertices[0].Color);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Add a control for ambient light</span></div><div class="line">    GlobalAmbient = <span class="keyword">new</span> CColorControl( guiEnv, core::position2d&lt;s32&gt;(550, 300), L<span class="stringliteral">&quot;Global ambient&quot;</span>, guiEnv-&gt;getRootGUIElement());</div><div class="line">    GlobalAmbient-&gt;setColor( smgr-&gt;getAmbientLight().toSColor() );</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> Update one frame </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> CApp::update()</div><div class="line">{</div><div class="line">    <span class="keyword">using namespace </span>irr;</div><div class="line"></div><div class="line">    video::IVideoDriver* videoDriver =  Device-&gt;getVideoDriver();</div><div class="line">    <span class="keywordflow">if</span> ( !Device-&gt;run() )</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Figure out delta time since last frame</span></div><div class="line">    ITimer * timer = Device-&gt;getTimer();</div><div class="line">    u32 newTick = timer-&gt;getRealTime();</div><div class="line">    f32 deltaTime = RealTimeTick &gt; 0 ? f32(newTick-RealTimeTick)/1000.f : 0.f;  <span class="comment">// in seconds</span></div><div class="line">    RealTimeTick = newTick;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( Device-&gt;isWindowActive() || Config.RenderInBackground )</div><div class="line">    {</div><div class="line">        gui::IGUIEnvironment* guiEnv = Device-&gt;getGUIEnvironment();</div><div class="line">        scene::ISceneManager* smgr = Device-&gt;getSceneManager();</div><div class="line">        gui::IGUISkin * skin = guiEnv-&gt;getSkin();</div><div class="line"></div><div class="line">        <span class="comment">// update our controls</span></div><div class="line">        MeshMaterialControl-&gt;update(SceneNode, SceneNode2T, SceneNodeTangents);</div><div class="line">        LightControl-&gt;update(NodeLight);</div><div class="line"></div><div class="line">        <span class="comment">// Update vertices</span></div><div class="line">        <span class="keywordflow">if</span> ( ControlVertexColors-&gt;isDirty() )</div><div class="line">        {</div><div class="line">            MeshManipulator-&gt;setVertexColors (SceneNode-&gt;getMesh(), ControlVertexColors-&gt;getColor());</div><div class="line">            MeshManipulator-&gt;setVertexColors (SceneNode2T-&gt;getMesh(), ControlVertexColors-&gt;getColor());</div><div class="line">            MeshManipulator-&gt;setVertexColors (SceneNodeTangents-&gt;getMesh(), ControlVertexColors-&gt;getColor());</div><div class="line">            ControlVertexColors-&gt;resetDirty();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// update ambient light settings</span></div><div class="line">        <span class="keywordflow">if</span> ( GlobalAmbient-&gt;isDirty() )</div><div class="line">        {</div><div class="line">            smgr-&gt;setAmbientLight( GlobalAmbient-&gt;getColor() );</div><div class="line">            GlobalAmbient-&gt;resetDirty();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Let the user move the light around</span></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> zoomSpeed = 10.f * deltaTime;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> rotationSpeed = 100.f * deltaTime;</div><div class="line">        <span class="keywordflow">if</span> ( KeysPressed[KEY_PLUS] || KeysPressed[KEY_ADD])</div><div class="line">            ZoomOut(NodeLight, zoomSpeed);</div><div class="line">        <span class="keywordflow">if</span> ( KeysPressed[KEY_MINUS] || KeysPressed[KEY_SUBTRACT])</div><div class="line">            ZoomOut(NodeLight, -zoomSpeed);</div><div class="line">        <span class="keywordflow">if</span> ( KeysPressed[KEY_RIGHT])</div><div class="line">            RotateHorizontal(NodeLight, rotationSpeed);</div><div class="line">        <span class="keywordflow">if</span> ( KeysPressed[KEY_LEFT])</div><div class="line">            RotateHorizontal(NodeLight, -rotationSpeed);</div><div class="line">        UpdateRotationAxis(NodeLight, LightRotationAxis);</div><div class="line">        <span class="keywordflow">if</span> ( KeysPressed[KEY_UP])</div><div class="line">            RotateAroundAxis(NodeLight, rotationSpeed, LightRotationAxis);</div><div class="line">        <span class="keywordflow">if</span> ( KeysPressed[KEY_DOWN])</div><div class="line">            RotateAroundAxis(NodeLight, -rotationSpeed, LightRotationAxis);</div><div class="line"></div><div class="line">        <span class="comment">// Let the user move the camera around</span></div><div class="line">        <span class="keywordflow">if</span> (MousePressed)</div><div class="line">        {</div><div class="line">            gui::ICursorControl* cursorControl = Device-&gt;getCursorControl();</div><div class="line">            <span class="keyword">const</span> core::position2d&lt;s32&gt;&amp; mousePos = cursorControl-&gt;getPosition ();</div><div class="line">            RotateHorizontal(Camera, rotationSpeed * (MouseStart.X - mousePos.X));</div><div class="line">            RotateAroundAxis(Camera, rotationSpeed * (mousePos.Y - MouseStart.Y), CameraRotationAxis);</div><div class="line">            MouseStart = mousePos;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// draw everything</span></div><div class="line">        video::SColor bkColor( skin-&gt;getColor(gui::EGDC_APP_WORKSPACE) );</div><div class="line">        videoDriver-&gt;beginScene(video::ECBF_COLOR | video::ECBF_DEPTH, bkColor);</div><div class="line"></div><div class="line">        smgr-&gt;drawAll();</div><div class="line">        guiEnv-&gt;drawAll();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ( MeshMaterialControl-&gt;isLightingEnabled() )</div><div class="line">        {</div><div class="line">            <span class="comment">// draw a line from the light to the target</span></div><div class="line">            video::SMaterial lineMaterial;</div><div class="line">            lineMaterial.Lighting = <span class="keyword">false</span>;</div><div class="line">            videoDriver-&gt;setMaterial(lineMaterial);</div><div class="line">            videoDriver-&gt;setTransform(video::ETS_WORLD, core::IdentityMatrix);</div><div class="line">            videoDriver-&gt;draw3DLine(NodeLight-&gt;getAbsolutePosition(), SceneNode-&gt;getAbsolutePosition());</div><div class="line">        }</div><div class="line"></div><div class="line">        videoDriver-&gt;endScene();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// be nice</span></div><div class="line">    Device-&gt;sleep( 5 );</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Close down the application</span></div><div class="line"><span class="keywordtype">void</span> CApp::quit()</div><div class="line">{</div><div class="line">    IsRunning = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">delete</span> LightControl;</div><div class="line">    LightControl = NULL;</div><div class="line"></div><div class="line">    <span class="keyword">delete</span> MeshMaterialControl;</div><div class="line">    MeshMaterialControl = NULL;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( ControlVertexColors )</div><div class="line">    {</div><div class="line">        ControlVertexColors-&gt;drop();</div><div class="line">        ControlVertexColors = NULL;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> ( GlobalAmbient )</div><div class="line">    {</div><div class="line">        GlobalAmbient-&gt;drop();</div><div class="line">        GlobalAmbient = NULL;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> ( Device )</div><div class="line">    {</div><div class="line">        Device-&gt;closeDevice();</div><div class="line">        Device-&gt;drop();</div><div class="line">        Device = NULL;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Create some useful textures.</span></div><div class="line"><span class="keywordtype">void</span> CApp::createDefaultTextures(video::IVideoDriver * driver)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> u32 width = 256;</div><div class="line">    <span class="keyword">const</span> u32 height = 256;</div><div class="line">    video::IImage * imageA8R8G8B8 = driver-&gt;createImage (video::ECF_A8R8G8B8, core::dimension2d&lt;u32&gt;(width, height));</div><div class="line">    <span class="keywordflow">if</span> ( !imageA8R8G8B8 )</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    <span class="keyword">const</span> u32 pitch = imageA8R8G8B8-&gt;getPitch();</div><div class="line"></div><div class="line">    <span class="comment">// Some nice square-pattern with 9 typical colors</span></div><div class="line">    <span class="comment">// Note that the function put readability over speed, you shouldn&#39;t use setPixel at runtime but for initialization it&#39;s nice.</span></div><div class="line">    <span class="keywordflow">for</span> ( u32 y = 0; y &lt; height; ++ y )</div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span> ( u32 x = 0; x &lt; pitch; ++x )</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> ( y &lt; height/3 )</div><div class="line">            {</div><div class="line">                <span class="keywordflow">if</span> ( x &lt; width/3 )</div><div class="line">                    imageA8R8G8B8-&gt;setPixel (x, y, SCOL_BLACK);</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( x &lt; 2*width/3 )</div><div class="line">                    imageA8R8G8B8-&gt;setPixel (x, y, SCOL_BLUE);</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                    imageA8R8G8B8-&gt;setPixel (x, y, SCOL_CYAN);</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( y &lt; 2*height/3 )</div><div class="line">            {</div><div class="line">                <span class="keywordflow">if</span> ( x &lt; width/3 )</div><div class="line">                    imageA8R8G8B8-&gt;setPixel (x, y, SCOL_GRAY);</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( x &lt; 2*width/3 )</div><div class="line">                    imageA8R8G8B8-&gt;setPixel (x, y, SCOL_GREEN);</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                    imageA8R8G8B8-&gt;setPixel (x, y, SCOL_MAGENTA);</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                <span class="keywordflow">if</span> ( x &lt; width/3 )</div><div class="line">                    imageA8R8G8B8-&gt;setPixel (x, y, SCOL_RED);</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( x &lt; 2*width/3 )</div><div class="line">                    imageA8R8G8B8-&gt;setPixel (x, y, SCOL_YELLOW);</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                    imageA8R8G8B8-&gt;setPixel (x, y, SCOL_WHITE);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    driver-&gt;addTexture (io::path(<span class="stringliteral">&quot;CARO_A8R8G8B8&quot;</span>), imageA8R8G8B8);</div><div class="line"></div><div class="line">    <span class="comment">// all white</span></div><div class="line">    imageA8R8G8B8-&gt;fill(SCOL_WHITE);</div><div class="line">    driver-&gt;addTexture (io::path(<span class="stringliteral">&quot;WHITE_A8R8G8B8&quot;</span>), imageA8R8G8B8);</div><div class="line"></div><div class="line">    <span class="comment">// all black</span></div><div class="line">    imageA8R8G8B8-&gt;fill(SCOL_BLACK);</div><div class="line">    driver-&gt;addTexture (io::path(<span class="stringliteral">&quot;BLACK_A8R8G8B8&quot;</span>), imageA8R8G8B8);</div><div class="line"></div><div class="line">    <span class="comment">// gray-scale</span></div><div class="line">    <span class="keywordflow">for</span> ( u32 y = 0; y &lt; height; ++ y )</div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span> ( u32 x = 0; x &lt; pitch; ++x )</div><div class="line">        {</div><div class="line">            imageA8R8G8B8-&gt;setPixel (x, y, video::SColor(y, x,x,x) );</div><div class="line">        }</div><div class="line">    }</div><div class="line">    driver-&gt;addTexture (io::path(<span class="stringliteral">&quot;GRAYSCALE_A8R8G8B8&quot;</span>), imageA8R8G8B8);</div><div class="line"></div><div class="line">    imageA8R8G8B8-&gt;drop();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Load a texture and make sure nodes know it when more textures are available.</span></div><div class="line"><span class="keywordtype">void</span> CApp::loadTexture(<span class="keyword">const</span> io::path &amp;name)</div><div class="line">{</div><div class="line">    Device-&gt;getVideoDriver()-&gt;getTexture(name);</div><div class="line">    MeshMaterialControl-&gt;updateTextures();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> CApp::RotateHorizontal(irr::scene::ISceneNode* node, irr::f32 angle)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> ( node )</div><div class="line">    {</div><div class="line">        core::vector3df pos(node-&gt;getPosition());</div><div class="line">        core::vector2df dir(pos.X, pos.Z);</div><div class="line">        dir.rotateBy(angle);</div><div class="line">        pos.X = dir.X;</div><div class="line">        pos.Z = dir.Y;</div><div class="line">        node-&gt;setPosition(pos);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> CApp::RotateAroundAxis(irr::scene::ISceneNode* node, irr::f32 angle, <span class="keyword">const</span> irr::core::vector3df&amp; axis)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> ( node )</div><div class="line">    {</div><div class="line">        <span class="comment">// TOOD: yeah, doesn&#39;t rotate around top/bottom yet. Fixes welcome.</span></div><div class="line">        core::vector3df pos(node-&gt;getPosition());</div><div class="line">        core::matrix4 mat;</div><div class="line">        mat.setRotationAxisRadians (core::degToRad(angle), axis);</div><div class="line">        mat.rotateVect(pos);</div><div class="line">        node-&gt;setPosition(pos);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> CApp::ZoomOut(irr::scene::ISceneNode* node, irr::f32 units)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> ( node )</div><div class="line">    {</div><div class="line">        core::vector3df pos(node-&gt;getPosition());</div><div class="line">        irr::f32 len = pos.getLength() + units;</div><div class="line">        pos.setLength(len);</div><div class="line">        node-&gt;setPosition(pos);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> CApp::UpdateRotationAxis(irr::scene::ISceneNode* node, irr::core::vector3df&amp; axis)</div><div class="line">{</div><div class="line">    <span class="comment">// Find a perpendicular axis to the x,z vector. If none found (vector straight up/down) continue to use the existing one.</span></div><div class="line">    core::vector3df pos(node-&gt;getPosition());</div><div class="line">    <span class="keywordflow">if</span> ( !core::equals(pos.X, 0.f) || !core::equals(pos.Z, 0.f) )</div><div class="line">    {</div><div class="line">        axis.X = -pos.Z;</div><div class="line">        axis.Z = pos.X;</div><div class="line">        axis.normalize();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Short main as most is done in classes. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">    CApp APP;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( !APP.init(argc, argv) )</div><div class="line">    {</div><div class="line">        printf(<span class="stringliteral">&quot;init failed\n&quot;</span>);</div><div class="line">        APP.quit();</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    APP.setRunning(<span class="keyword">true</span>);</div></div><!-- fragment --><p> main application loop </p><div class="fragment"><div class="line">    <span class="keywordflow">while</span>(APP.isRunning())</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> ( !APP.update() )</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    APP.quit();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<p>&nbsp;</p>
</body>
</html>
