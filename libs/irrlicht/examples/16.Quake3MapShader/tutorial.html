<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tutorial 16: Quake3 Map Shader Support</title>
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Wanted to avoid copying .css to each folder, so copied default .css from doxyen in here, kicked out most stuff we don't need for examples and modified some a little bit. 
     Target was having a single html in each example folder which is created from the main.cpp files and needs no files besides some images below media folder.
     Feel free to improve :)
	 -->
<style>
body, table, div, p, dl {
	font: 400 14px/22px;
}
body {
	background-color: #F0F0F0;
	color: black;
	margin-left: 5%;
	margin-right: 5%;
}
p.reference, p.definition {
	font: 400 14px/22px;
}
.title {
	font: 400 14px/28px;
	font-size: 150%;
	font-weight: bold;
	margin: 10px 2px;
}
h1, h2, h3, h4, h5, h6 {
	-webkit-transition: text-shadow 0.5s linear;
	-moz-transition: text-shadow 0.5s linear;
	-ms-transition: text-shadow 0.5s linear;
	-o-transition: text-shadow 0.5s linear;
	transition: text-shadow 0.5s linear;
	margin-right: 15px;
}
caption {
	font-weight: bold;
}
h3.version {
	font-size: 90%;
	text-align: center;
}
a {
	color: #3D578C;
	font-weight: normal;
	text-decoration: none;
}
.contents a:visited {
	color: #4665A2;
}
a:hover {
	text-decoration: underline;
}
a.el {
	font-weight: bold;
}
a.code, a.code:visited, a.line, a.line:visited {
	color: #4665A2; 
}
a.codeRef, a.codeRef:visited, a.lineRef, a.lineRef:visited {
	color: #4665A2; 
}
pre.fragment {
	border: 1px solid #C4CFE5;
	background-color: #FBFCFD;
	padding: 4px 6px;
	margin: 4px 8px 4px 2px;
	overflow: auto;
	word-wrap: break-word;
	font-size:  9pt;
	line-height: 125%;
	font-family: monospace, fixed;
	font-size: 105%;
}
div.fragment {
	padding: 0px;
	margin: 4px 8px 4px 2px;
	background-color: #FBFCFD;
	border: 1px solid #C4CFE5;
}
div.line {
	font-family: monospace, fixed;
	font-size: 13px;
	min-height: 13px;
	line-height: 1.0;
	text-wrap: unrestricted;
	white-space: -moz-pre-wrap; /* Moz */
	white-space: -pre-wrap;     /* Opera 4-6 */
	white-space: -o-pre-wrap;   /* Opera 7 */
	white-space: pre-wrap;      /* CSS3  */
	word-wrap: break-word;      /* IE 5.5+ */
	text-indent: -53px;
	padding-left: 53px;
	padding-bottom: 0px;
	margin: 0px;
	-webkit-transition-property: background-color, box-shadow;
	-webkit-transition-duration: 0.5s;
	-moz-transition-property: background-color, box-shadow;
	-moz-transition-duration: 0.5s;
	-ms-transition-property: background-color, box-shadow;
	-ms-transition-duration: 0.5s;
	-o-transition-property: background-color, box-shadow;
	-o-transition-duration: 0.5s;
	transition-property: background-color, box-shadow;
	transition-duration: 0.5s;
}
div.contents {
	margin-top: 10px;
	margin-left: 12px;
	margin-right: 8px;
}
div.center {
	text-align: center;
	margin-top: 0px;
	margin-bottom: 0px;
	padding: 0px;
}
div.center img {
	border: 0px;
}
span.keyword {
	color: #008000
}
span.keywordtype {
	color: #604020
}
span.keywordflow {
	color: #e08000
}
span.comment {
	color: #800000
}
span.preprocessor {
	color: #806020
}
span.stringliteral {
	color: #002080
}
span.charliteral {
	color: #008080
}
blockquote {
	background-color: #F7F8FB;
	border-left: 2px solid #9CAFD4;
	margin: 0 24px 0 4px;
	padding: 0 12px 0 16px;
}
hr {
	height: 0px;
	border: none;
	border-top: 1px solid #4A6AAA;
}
address {
	font-style: normal;
	color: #2A3D61;
}
div.header {
	background-image:url('nav_h.png');
	background-repeat:repeat-x;
	background-color: #F9FAFC;
	margin:  0px;
	border-bottom: 1px solid #C4CFE5;
}
div.headertitle {
	padding: 5px 5px 5px 10px;
}
.image {
	text-align: center;
}
.caption {
	font-weight: bold;
}
div.zoom {
	border: 1px solid #90A5CE;
}
tr.heading h2 {
	margin-top: 12px;
	margin-bottom: 4px;
}
</style>
</head>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!--END TITLEAREA-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 16: Quake3 Map Shader Support </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="../../media/example_screenshots/016shot.jpg" alt="016shot.jpg"/>
</div>
 <p>This tutorial shows how to load a Quake 3 map into the engine, create a SceneNode for optimizing the speed of rendering and how to create a user controlled camera.</p>
<p>Lets start like the HelloWorld example: We include the irrlicht header files and an additional file to be able to ask the user for a driver type using the console. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;irrlicht.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;driverChoice.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;exampleHelper.h&quot;</span></div></div><!-- fragment --><p> define which Quake3 Level should be loaded </p><div class="fragment"><div class="line"><span class="preprocessor">#define IRRLICHT_QUAKE3_ARENA</span></div><div class="line"><span class="comment">//#define ORIGINAL_QUAKE3_ARENA</span></div><div class="line"><span class="comment">//#define CUSTOM_QUAKE3_ARENA</span></div><div class="line"><span class="comment">//#define SHOW_SHADER_NAME</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef ORIGINAL_QUAKE3_ARENA</span></div><div class="line"><span class="preprocessor">    #define QUAKE3_STORAGE_FORMAT   addFolderFileArchive</span></div><div class="line"><span class="preprocessor">    #define QUAKE3_STORAGE_1        &quot;/baseq3/&quot;</span></div><div class="line"><span class="preprocessor">    #ifdef CUSTOM_QUAKE3_ARENA</span></div><div class="line"><span class="preprocessor">        #define QUAKE3_STORAGE_2    &quot;/cf/&quot;</span></div><div class="line"><span class="preprocessor">        #define QUAKE3_MAP_NAME     &quot;maps/cf.bsp&quot;</span></div><div class="line"><span class="preprocessor">    #else</span></div><div class="line"><span class="preprocessor">        #define QUAKE3_MAP_NAME         &quot;maps/q3dm8.bsp&quot;</span></div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef IRRLICHT_QUAKE3_ARENA</span></div><div class="line"><span class="preprocessor">    #define QUAKE3_STORAGE_FORMAT   addFileArchive</span></div><div class="line"><span class="preprocessor">    #define QUAKE3_STORAGE_1    getExampleMediaPath() + &quot;map-20kdm2.pk3&quot;</span></div><div class="line"><span class="preprocessor">    #define QUAKE3_MAP_NAME         &quot;maps/20kdm2.bsp&quot;</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>irr;</div><div class="line"><span class="keyword">using namespace </span>scene;</div></div><!-- fragment --><p> Again, to be able to use the Irrlicht.DLL file, we need to link with the Irrlicht.lib. We could set this option in the project settings, but to make it easy, we use a pragma comment lib: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef _MSC_VER</span></div><div class="line"><span class="preprocessor">#pragma comment(lib, &quot;Irrlicht.lib&quot;)</span></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p> A class to produce a series of screenshots </p><div class="fragment"><div class="line"><span class="keyword">class </span>CScreenShotFactory : <span class="keyword">public</span> IEventReceiver</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    CScreenShotFactory( IrrlichtDevice *device, <span class="keyword">const</span> c8 * templateName, ISceneNode* node )</div><div class="line">        : Device(device), Number(0), FilenameTemplate(templateName), Node(node)</div><div class="line">    {</div><div class="line">        FilenameTemplate.replace ( <span class="charliteral">&#39;/&#39;</span>, <span class="charliteral">&#39;_&#39;</span> );</div><div class="line">        FilenameTemplate.replace ( <span class="charliteral">&#39;\\&#39;</span>, <span class="charliteral">&#39;_&#39;</span> );</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> OnEvent(<span class="keyword">const</span> SEvent&amp; event)</div><div class="line">    {</div><div class="line">        <span class="comment">// check if user presses the key F9</span></div><div class="line">        <span class="keywordflow">if</span> ((event.EventType == EET_KEY_INPUT_EVENT) &amp;&amp;</div><div class="line">                event.KeyInput.PressedDown)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (event.KeyInput.Key == KEY_F9)</div><div class="line">            {</div><div class="line">                video::IImage* image = Device-&gt;getVideoDriver()-&gt;createScreenShot();</div><div class="line">                <span class="keywordflow">if</span> (image)</div><div class="line">                {</div><div class="line">                    c8 buf[256];</div><div class="line">                    snprintf_irr(buf, 256, <span class="stringliteral">&quot;%s_shot%04d.jpg&quot;</span>,</div><div class="line">                            FilenameTemplate.c_str(),</div><div class="line">                            ++Number);</div><div class="line">                    Device-&gt;getVideoDriver()-&gt;writeImageToFile(image, buf, 85 );</div><div class="line">                    image-&gt;drop();</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            <span class="keywordflow">if</span> (event.KeyInput.Key == KEY_F8)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">if</span> (Node-&gt;isDebugDataVisible())</div><div class="line">                    Node-&gt;setDebugDataVisible(scene::EDS_OFF);</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                    Node-&gt;setDebugDataVisible(scene::EDS_BBOX_ALL);</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    IrrlichtDevice *Device;</div><div class="line">    u32 Number;</div><div class="line">    core::stringc FilenameTemplate;</div><div class="line">    ISceneNode* Node;</div><div class="line">};</div></div><!-- fragment --><p> Ok, lets start. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> IRRCALLCONV main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div></div><!-- fragment --><p> Like in the HelloWorld example, we create an IrrlichtDevice with createDevice(). The difference now is that we ask the user to select which hardware accelerated driver to use. The Software device would be too slow to draw a huge Quake 3 map, but just for the fun of it, we make this decision possible too. </p><div class="fragment"><div class="line"><span class="comment">// ask user for driver</span></div><div class="line">video::E_DRIVER_TYPE driverType=driverChoiceConsole();</div><div class="line"><span class="keywordflow">if</span> (driverType==video::EDT_COUNT)</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line"></div><div class="line"><span class="comment">// create device and exit if creation failed</span></div><div class="line"><span class="keyword">const</span> core::dimension2du videoDim(800,600);</div><div class="line"></div><div class="line">IrrlichtDevice *device = createDevice(driverType, videoDim, 32, <span class="keyword">false</span> );</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (device == 0)</div><div class="line">    <span class="keywordflow">return</span> 1; <span class="comment">// could not create selected driver.</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* mapname=0;</div><div class="line"><span class="keywordflow">if</span> (argc&gt;2)</div><div class="line">    mapname = argv[2];</div><div class="line"><span class="keywordflow">else</span></div><div class="line">    mapname = QUAKE3_MAP_NAME;</div></div><!-- fragment --><p> Get a pointer to the video driver and the SceneManager so that we do not always have to write device-&gt;getVideoDriver() and device-&gt;getSceneManager(). </p><div class="fragment"><div class="line">video::IVideoDriver* driver = device-&gt;getVideoDriver();</div><div class="line">scene::ISceneManager* smgr = device-&gt;getSceneManager();</div><div class="line">gui::IGUIEnvironment* gui = device-&gt;getGUIEnvironment();</div><div class="line"></div><div class="line"><span class="keyword">const</span> io::path mediaPath = getExampleMediaPath();</div><div class="line"></div><div class="line">device-&gt;getFileSystem()-&gt;addFileArchive(mediaPath);</div></div><!-- fragment --><p> To display the Quake 3 map, we first need to load it. Quake 3 maps are packed into .pk3 files, which are nothing other than .zip files. So we add the .pk3 file to our FileSystem. After it was added, we are able to read from the files in that archive as they would directly be stored on disk. </p><div class="fragment"><div class="line">    <span class="keywordflow">if</span> (argc&gt;2)</div><div class="line">        device-&gt;getFileSystem()-&gt;QUAKE3_STORAGE_FORMAT(argv[1]);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        device-&gt;getFileSystem()-&gt;QUAKE3_STORAGE_FORMAT(QUAKE3_STORAGE_1);</div><div class="line"><span class="preprocessor">#ifdef QUAKE3_STORAGE_2</span></div><div class="line">    device-&gt;getFileSystem()-&gt;QUAKE3_STORAGE_FORMAT(QUAKE3_STORAGE_2);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">// Quake3 Shader controls Z-Writing</span></div><div class="line">    smgr-&gt;getParameters()-&gt;setAttribute(scene::ALLOW_ZWRITE_ON_TRANSPARENT, <span class="keyword">true</span>);</div></div><!-- fragment --><p> Now we can load the mesh by calling getMesh(). We get a pointer returned to a IAnimatedMesh. As you know, Quake 3 maps are not really animated, they are only a huge chunk of static geometry with some materials attached. Hence the IAnimated mesh consists of only one frame, so we get the "first frame" of the "animation", which is our quake level and create an Octree scene node with it, using addOctreeSceneNode(). The Octree optimizes the scene a little bit, trying to draw only geometry which is currently visible. An alternative to the Octree would be a AnimatedMeshSceneNode, which would draw always the complete geometry of the mesh, without optimization. Try it out: Write addAnimatedMeshSceneNode instead of addOctreeSceneNode and compare the primitives drawn by the video driver. (There is a getPrimitiveCountDrawed() method in the IVideoDriver class). Note that this optimization with the Octree is only useful when drawing huge meshes consisting of lots of geometry. </p><div class="fragment"><div class="line">scene::IQ3LevelMesh* <span class="keyword">const</span> mesh =</div><div class="line">    (scene::IQ3LevelMesh*) smgr-&gt;getMesh(mapname);</div></div><!-- fragment --><p> add the geometry mesh to the Scene ( polygon &amp; patches ) The Geometry mesh is optimised for faster drawing </p><div class="fragment"><div class="line">scene::ISceneNode* node = 0;</div><div class="line"><span class="keywordflow">if</span> (mesh)</div><div class="line">{</div><div class="line">    scene::IMesh * <span class="keyword">const</span> geometry = mesh-&gt;getMesh(quake3::E_Q3_MESH_GEOMETRY);</div><div class="line">    node = smgr-&gt;addOctreeSceneNode(geometry, 0, -1, 4096);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// create an event receiver for making screenshots</span></div><div class="line">CScreenShotFactory screenshotFactory(device, mapname, node);</div><div class="line">device-&gt;setEventReceiver(&amp;screenshotFactory);</div></div><!-- fragment --><p> now construct SceneNodes for each Shader The Objects are stored in the quake mesh scene::E_Q3_MESH_ITEMS and the Shader ID is stored in the MaterialParameters mostly dark looking skulls and moving lava.. or green flashing tubes? </p><div class="fragment"><div class="line">    <span class="keywordflow">if</span> ( mesh )</div><div class="line">    {</div><div class="line">        <span class="comment">// the additional mesh can be quite huge and is unoptimized</span></div><div class="line">        <span class="keyword">const</span> scene::IMesh * <span class="keyword">const</span> additional_mesh = mesh-&gt;getMesh(quake3::E_Q3_MESH_ITEMS);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef SHOW_SHADER_NAME</span></div><div class="line">        gui::IGUIFont *font = device-&gt;getGUIEnvironment()-&gt;getFont(mediaPath + <span class="stringliteral">&quot;fontlucida.png&quot;</span>);</div><div class="line">        u32 count = 0;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> ( u32 i = 0; i!= additional_mesh-&gt;getMeshBufferCount(); ++i )</div><div class="line">        {</div><div class="line">            <span class="keyword">const</span> IMeshBuffer* meshBuffer = additional_mesh-&gt;getMeshBuffer(i);</div><div class="line">            <span class="keyword">const</span> video::SMaterial&amp; material = meshBuffer-&gt;getMaterial();</div><div class="line"></div><div class="line">            <span class="comment">// The ShaderIndex is stored in the material parameter</span></div><div class="line">            <span class="keyword">const</span> s32 shaderIndex = (s32) material.MaterialTypeParam2;</div><div class="line"></div><div class="line">            <span class="comment">// the meshbuffer can be rendered without additional support, or it has no shader</span></div><div class="line">            <span class="keyword">const</span> quake3::IShader *shader = mesh-&gt;getShader(shaderIndex);</div><div class="line">            <span class="keywordflow">if</span> (0 == shader)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">continue</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// we can dump the shader to the console in its</span></div><div class="line">            <span class="comment">// original but already parsed layout in a pretty</span></div><div class="line">            <span class="comment">// printers way.. commented out, because the console</span></div><div class="line">            <span class="comment">// would be full...</span></div><div class="line">            <span class="comment">// quake3::dumpShader ( Shader );</span></div><div class="line"></div><div class="line">            node = smgr-&gt;addQuake3SceneNode(meshBuffer, shader);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef SHOW_SHADER_NAME</span></div><div class="line">            count += 1;</div><div class="line">            core::stringw name( node-&gt;getName() );</div><div class="line">            node = smgr-&gt;addBillboardTextSceneNode(</div><div class="line">                    font, name.c_str(), node,</div><div class="line">                    core::dimension2d&lt;f32&gt;(80.0f, 8.0f),</div><div class="line">                    core::vector3df(0, 10, 0));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p> Now we only need a Camera to look at the Quake 3 map. And we want to create a user controlled camera. There are some different cameras available in the Irrlicht engine. For example the Maya Camera which can be controlled comparable to the camera in Maya: Rotate with left mouse button pressed, Zoom with both buttons pressed, translate with right mouse button pressed. This could be created with addCameraSceneNodeMaya(). But for this example, we want to create a camera which behaves like the ones in first person shooter games (FPS). </p><div class="fragment"><div class="line">scene::ICameraSceneNode* camera = smgr-&gt;addCameraSceneNodeFPS();</div></div><!-- fragment --><p> so we need a good starting Position in the level. we can ask the Quake3 Loader for all entities with class_name "info_player_deathmatch" we choose a random launch </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> ( mesh )</div><div class="line">{</div><div class="line">    quake3::tQ3EntityList &amp;entityList = mesh-&gt;getEntityList();</div><div class="line"></div><div class="line">    quake3::IEntity search;</div><div class="line">    search.name = <span class="stringliteral">&quot;info_player_deathmatch&quot;</span>;</div><div class="line"></div><div class="line">    s32 index = entityList.binary_search(search);</div><div class="line">    <span class="keywordflow">if</span> (index &gt;= 0)</div><div class="line">    {</div><div class="line">        s32 notEndList;</div><div class="line">        <span class="keywordflow">do</span></div><div class="line">        {</div><div class="line">            <span class="keyword">const</span> quake3::SVarGroup *group = entityList[index].getGroup(1);</div><div class="line"></div><div class="line">            u32 parsepos = 0;</div><div class="line">            <span class="keyword">const</span> core::vector3df pos =</div><div class="line">                quake3::getAsVector3df(group-&gt;get(<span class="stringliteral">&quot;origin&quot;</span>), parsepos);</div><div class="line"></div><div class="line">            parsepos = 0;</div><div class="line">            <span class="keyword">const</span> f32 angle = quake3::getAsFloat(group-&gt;get(<span class="stringliteral">&quot;angle&quot;</span>), parsepos);</div><div class="line"></div><div class="line">            core::vector3df target(0.f, 0.f, 1.f);</div><div class="line">            target.rotateXZBy(angle);</div><div class="line"></div><div class="line">            camera-&gt;setPosition(pos);</div><div class="line">            camera-&gt;setTarget(pos + target);</div><div class="line"></div><div class="line">            ++index;</div></div><!-- fragment --><p> notEndList = ( index &lt; (s32) entityList.size () &amp;&amp; entityList[index].name == search.name &amp;&amp; (device-&gt;getTimer()-&gt;getRealTime() &gt;&gt; 3 ) &amp; 1 ); </p><div class="fragment"><div class="line">            notEndList = index == 2;</div><div class="line">        } <span class="keywordflow">while</span> ( notEndList );</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> The mouse cursor needs not to be visible, so we make it invisible. </p><div class="fragment"><div class="line">device-&gt;getCursorControl()-&gt;setVisible(<span class="keyword">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// load the engine logo</span></div><div class="line">gui-&gt;addImage(driver-&gt;getTexture(<span class="stringliteral">&quot;irrlichtlogo3.png&quot;</span>),</div><div class="line">        core::position2d&lt;s32&gt;(10, 10));</div><div class="line"></div><div class="line"><span class="comment">// show the driver logo</span></div><div class="line"><span class="keyword">const</span> core::position2di pos(videoDim.Width - 128, videoDim.Height - 64);</div><div class="line"></div><div class="line"><span class="keywordflow">switch</span> ( driverType )</div><div class="line">{</div><div class="line">    <span class="keywordflow">case</span> video::EDT_BURNINGSVIDEO:</div><div class="line">        gui-&gt;addImage(driver-&gt;getTexture(<span class="stringliteral">&quot;burninglogo.png&quot;</span>), pos);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> video::EDT_OPENGL:</div><div class="line">        gui-&gt;addImage(driver-&gt;getTexture(<span class="stringliteral">&quot;opengllogo.png&quot;</span>), pos);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> video::EDT_DIRECT3D9:</div><div class="line">        gui-&gt;addImage(driver-&gt;getTexture(<span class="stringliteral">&quot;directxlogo.png&quot;</span>), pos);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">}</div></div><!-- fragment --><p> We have done everything, so lets draw it. We also write the current frames per second and the drawn primitives to the caption of the window. The 'if (device-&gt;isWindowActive())' line is optional, but prevents the engine render to set the position of the mouse cursor after task switching when other program are active. </p><div class="fragment"><div class="line">    <span class="keywordtype">int</span> lastFPS = -1;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(device-&gt;run())</div><div class="line">    <span class="keywordflow">if</span> (device-&gt;isWindowActive())</div><div class="line">    {</div><div class="line">        driver-&gt;beginScene(video::ECBF_COLOR | video::ECBF_DEPTH, video::SColor(255,20,20,40));</div><div class="line">        smgr-&gt;drawAll();</div><div class="line">        gui-&gt;drawAll();</div><div class="line">        driver-&gt;endScene();</div><div class="line"></div><div class="line">        <span class="keywordtype">int</span> fps = driver-&gt;getFPS();</div><div class="line">        <span class="keywordflow">if</span> (1 || lastFPS != fps)</div><div class="line">        {</div><div class="line">            core::stringw str = L<span class="stringliteral">&quot;Q3 [&quot;</span>;</div><div class="line">            str += driver-&gt;getName();</div><div class="line">            str += <span class="stringliteral">&quot;] FPS:&quot;</span>;</div><div class="line">            str += fps;</div><div class="line"><span class="preprocessor">#ifdef _IRR_SCENEMANAGER_DEBUG          </span></div><div class="line">            io::IAttributes * <span class="keyword">const</span> attr = smgr-&gt;getParameters();</div><div class="line">            str += <span class="stringliteral">&quot; Cull:&quot;</span>;</div><div class="line">            str += attr-&gt;getAttributeAsInt(<span class="stringliteral">&quot;calls&quot;</span>);</div><div class="line">            str += <span class="stringliteral">&quot;/&quot;</span>;</div><div class="line">            str += attr-&gt;getAttributeAsInt(<span class="stringliteral">&quot;culled&quot;</span>);</div><div class="line">            str += <span class="stringliteral">&quot; Draw: &quot;</span>;</div><div class="line">            str += attr-&gt;getAttributeAsInt(<span class="stringliteral">&quot;drawn_solid&quot;</span>);</div><div class="line">            str += <span class="stringliteral">&quot;/&quot;</span>;</div><div class="line">            str += attr-&gt;getAttributeAsInt(<span class="stringliteral">&quot;drawn_transparent&quot;</span>);</div><div class="line">            str += <span class="stringliteral">&quot;/&quot;</span>;</div><div class="line">            str += attr-&gt;getAttributeAsInt(<span class="stringliteral">&quot;drawn_transparent_effect&quot;</span>);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">            device-&gt;setWindowCaption(str.c_str());</div><div class="line">            lastFPS = fps;</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p> In the end, delete the Irrlicht device. </p><div class="fragment"><div class="line">    device-&gt;drop();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<p>&nbsp;</p>
</body>
</html>
