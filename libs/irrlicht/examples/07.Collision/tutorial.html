<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tutorial 7: Collision</title>
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Wanted to avoid copying .css to each folder, so copied default .css from doxyen in here, kicked out most stuff we don't need for examples and modified some a little bit. 
     Target was having a single html in each example folder which is created from the main.cpp files and needs no files besides some images below media folder.
     Feel free to improve :)
	 -->
<style>
body, table, div, p, dl {
	font: 400 14px/22px;
}
body {
	background-color: #F0F0F0;
	color: black;
	margin-left: 5%;
	margin-right: 5%;
}
p.reference, p.definition {
	font: 400 14px/22px;
}
.title {
	font: 400 14px/28px;
	font-size: 150%;
	font-weight: bold;
	margin: 10px 2px;
}
h1, h2, h3, h4, h5, h6 {
	-webkit-transition: text-shadow 0.5s linear;
	-moz-transition: text-shadow 0.5s linear;
	-ms-transition: text-shadow 0.5s linear;
	-o-transition: text-shadow 0.5s linear;
	transition: text-shadow 0.5s linear;
	margin-right: 15px;
}
caption {
	font-weight: bold;
}
h3.version {
	font-size: 90%;
	text-align: center;
}
a {
	color: #3D578C;
	font-weight: normal;
	text-decoration: none;
}
.contents a:visited {
	color: #4665A2;
}
a:hover {
	text-decoration: underline;
}
a.el {
	font-weight: bold;
}
a.code, a.code:visited, a.line, a.line:visited {
	color: #4665A2; 
}
a.codeRef, a.codeRef:visited, a.lineRef, a.lineRef:visited {
	color: #4665A2; 
}
pre.fragment {
	border: 1px solid #C4CFE5;
	background-color: #FBFCFD;
	padding: 4px 6px;
	margin: 4px 8px 4px 2px;
	overflow: auto;
	word-wrap: break-word;
	font-size:  9pt;
	line-height: 125%;
	font-family: monospace, fixed;
	font-size: 105%;
}
div.fragment {
	padding: 0px;
	margin: 4px 8px 4px 2px;
	background-color: #FBFCFD;
	border: 1px solid #C4CFE5;
}
div.line {
	font-family: monospace, fixed;
	font-size: 13px;
	min-height: 13px;
	line-height: 1.0;
	text-wrap: unrestricted;
	white-space: -moz-pre-wrap; /* Moz */
	white-space: -pre-wrap;     /* Opera 4-6 */
	white-space: -o-pre-wrap;   /* Opera 7 */
	white-space: pre-wrap;      /* CSS3  */
	word-wrap: break-word;      /* IE 5.5+ */
	text-indent: -53px;
	padding-left: 53px;
	padding-bottom: 0px;
	margin: 0px;
	-webkit-transition-property: background-color, box-shadow;
	-webkit-transition-duration: 0.5s;
	-moz-transition-property: background-color, box-shadow;
	-moz-transition-duration: 0.5s;
	-ms-transition-property: background-color, box-shadow;
	-ms-transition-duration: 0.5s;
	-o-transition-property: background-color, box-shadow;
	-o-transition-duration: 0.5s;
	transition-property: background-color, box-shadow;
	transition-duration: 0.5s;
}
div.contents {
	margin-top: 10px;
	margin-left: 12px;
	margin-right: 8px;
}
div.center {
	text-align: center;
	margin-top: 0px;
	margin-bottom: 0px;
	padding: 0px;
}
div.center img {
	border: 0px;
}
span.keyword {
	color: #008000
}
span.keywordtype {
	color: #604020
}
span.keywordflow {
	color: #e08000
}
span.comment {
	color: #800000
}
span.preprocessor {
	color: #806020
}
span.stringliteral {
	color: #002080
}
span.charliteral {
	color: #008080
}
blockquote {
	background-color: #F7F8FB;
	border-left: 2px solid #9CAFD4;
	margin: 0 24px 0 4px;
	padding: 0 12px 0 16px;
}
hr {
	height: 0px;
	border: none;
	border-top: 1px solid #4A6AAA;
}
address {
	font-style: normal;
	color: #2A3D61;
}
div.header {
	background-image:url('nav_h.png');
	background-repeat:repeat-x;
	background-color: #F9FAFC;
	margin:  0px;
	border-bottom: 1px solid #C4CFE5;
}
div.headertitle {
	padding: 5px 5px 5px 10px;
}
.image {
	text-align: center;
}
.caption {
	font-weight: bold;
}
div.zoom {
	border: 1px solid #90A5CE;
}
tr.heading h2 {
	margin-top: 12px;
	margin-bottom: 4px;
}
</style>
</head>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!--END TITLEAREA-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 7: Collision </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="../../media/example_screenshots/007shot.jpg" alt="007shot.jpg"/>
</div>
 <p>We will describe 2 methods: Automatic collision detection for moving through 3d worlds with stair climbing and sliding, and manual scene node and triangle picking using a ray. In this case, we will use a ray coming out from the camera, but you can use any ray.</p>
<p>To start, we take the program from tutorial 2, which loads and displays a quake 3 level. We will use the level to walk in it and to pick triangles from. In addition we'll place 3 animated models into it for triangle picking. The following code starts up the engine and loads the level, as per tutorial 2. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;irrlicht.h&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;driverChoice.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;exampleHelper.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>irr;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef _MSC_VER</span></div><div class="line"><span class="preprocessor">#pragma comment(lib, &quot;Irrlicht.lib&quot;)</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span></div><div class="line">{</div><div class="line">    <span class="comment">// I use this ISceneNode ID to indicate a scene node that is</span></div><div class="line">    <span class="comment">// not pickable by getSceneNodeAndCollisionPointFromRay()</span></div><div class="line">    ID_IsNotPickable = 0,</div><div class="line"></div><div class="line">    <span class="comment">// I use this flag in ISceneNode IDs to indicate that the</span></div><div class="line">    <span class="comment">// scene node can be picked by ray selection.</span></div><div class="line">    IDFlag_IsPickable = 1 &lt;&lt; 0,</div><div class="line"></div><div class="line">    <span class="comment">// I use this flag in ISceneNode IDs to indicate that the</span></div><div class="line">    <span class="comment">// scene node can be highlighted.  In this example, the</span></div><div class="line">    <span class="comment">// homonids can be highlighted, but the level mesh can&#39;t.</span></div><div class="line">    IDFlag_IsHighlightable = 1 &lt;&lt; 1</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// ask user for driver</span></div><div class="line">    video::E_DRIVER_TYPE driverType=driverChoiceConsole();</div><div class="line">    <span class="keywordflow">if</span> (driverType==video::EDT_COUNT)</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line"></div><div class="line">    <span class="comment">// create device</span></div><div class="line"></div><div class="line">    IrrlichtDevice *device =</div><div class="line">        createDevice(driverType, core::dimension2d&lt;u32&gt;(640, 480), 16, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (device == 0)</div><div class="line">        <span class="keywordflow">return</span> 1; <span class="comment">// could not create selected driver.</span></div></div><!-- fragment --><p> If we want to receive information about the material of a hit triangle we have to get collisions per meshbuffer. The only disadvantage of this is that getting them per meshbuffer can be a little bit slower than per mesh, but usually that's not noticeable. If you set this to false you will no longer get material names in the title bar. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> separateMeshBuffers = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">video::IVideoDriver* driver = device-&gt;getVideoDriver();</div><div class="line">scene::ISceneManager* smgr = device-&gt;getSceneManager();</div><div class="line"></div><div class="line"><span class="keyword">const</span> io::path mediaPath = getExampleMediaPath();</div><div class="line"></div><div class="line">device-&gt;getFileSystem()-&gt;addFileArchive(mediaPath + <span class="stringliteral">&quot;map-20kdm2.pk3&quot;</span>);</div><div class="line"></div><div class="line">scene::IAnimatedMesh* q3levelmesh = smgr-&gt;getMesh(<span class="stringliteral">&quot;20kdm2.bsp&quot;</span>);</div><div class="line">scene::IMeshSceneNode* q3node = 0;</div><div class="line"></div><div class="line"><span class="comment">// The Quake mesh is pickable, but doesn&#39;t get highlighted.</span></div><div class="line"><span class="keywordflow">if</span> (q3levelmesh)</div><div class="line">    q3node = smgr-&gt;addOctreeSceneNode(q3levelmesh-&gt;getMesh(0), 0, IDFlag_IsPickable);</div></div><!-- fragment --><p> So far so good, we've loaded the quake 3 level like in tutorial 2. Now, here comes something different: We create a triangle selector. A triangle selector is a class which can fetch the triangles from scene nodes for doing different things with them, for example collision detection. There are different triangle selectors, and all can be created with the ISceneManager. In this example, we create an OctreeTriangleSelector, which optimizes the triangle output a little bit by reducing it like an octree. This is very useful for huge meshes like quake 3 levels. After we created the triangle selector, we attach it to the q3node. This is not necessary, but in this way, we do not need to care for the selector, for example dropping it after we do not need it anymore. </p><div class="fragment"><div class="line">scene::ITriangleSelector* selector = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (q3node)</div><div class="line">{</div><div class="line">    q3node-&gt;setPosition(core::vector3df(-1350,-130,-1400));</div></div><!-- fragment --><p> There is currently no way to split an octree by material. So if we need material infos we have to create one octree per meshbuffer and put them together in a MetaTriangleSelector. </p><div class="fragment"><div class="line">    <span class="keywordflow">if</span> ( separateMeshBuffers &amp;&amp; q3node-&gt;getMesh()-&gt;getMeshBufferCount() &gt; 1)</div><div class="line">    {</div><div class="line">        scene::IMetaTriangleSelector * metaSelector = smgr-&gt;createMetaTriangleSelector();</div><div class="line">        <span class="keywordflow">for</span> ( irr::u32 m=0; m &lt; q3node-&gt;getMesh()-&gt;getMeshBufferCount(); ++m )</div><div class="line">        {</div><div class="line">            scene::ITriangleSelector*</div><div class="line">                bufferSelector = smgr-&gt;createOctreeTriangleSelector(</div><div class="line">                q3node-&gt;getMesh()-&gt;getMeshBuffer(m), m, q3node);</div><div class="line">            <span class="keywordflow">if</span> ( bufferSelector )</div><div class="line">            {</div><div class="line">                metaSelector-&gt;addTriangleSelector( bufferSelector );</div><div class="line">                bufferSelector-&gt;drop();</div><div class="line">            }</div><div class="line">        }</div><div class="line">        selector = metaSelector;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">// If you don&#39;t need material infos just create one octree for the </span></div><div class="line">        <span class="comment">// whole mesh.</span></div><div class="line">        selector = smgr-&gt;createOctreeTriangleSelector(</div><div class="line">                q3node-&gt;getMesh(), q3node, 128);</div><div class="line">    }</div><div class="line">    q3node-&gt;setTriangleSelector(selector);</div><div class="line">    <span class="comment">// We&#39;re not done with this selector yet, so don&#39;t drop it.</span></div><div class="line">}</div></div><!-- fragment --><p> We add a first person shooter camera to the scene so that we can see and move in the quake 3 level like in tutorial 2. But this, time, we add a special animator to the camera: A collision response animator. This animator modifies the scene node to which it is attached in order to prevent it from moving through walls and to add gravity to the node. The only things we have to tell the animator is how the world looks like, how big the scene node is, how much gravity to apply and so on. After the collision response animator is attached to the camera, we do not have to do anything else for collision detection, it's all done automatically. The rest of the collision detection code below is for picking. And please note another cool feature: The collision response animator can be attached also to all other scene nodes, not only to cameras. And it can be mixed with other scene node animators. In this way, collision detection and response in the Irrlicht engine is really easy.</p>
<p>Now we'll take a closer look on the parameters of createCollisionResponseAnimator(). The first parameter is the TriangleSelector, which specifies how the world, against which collision detection is done, looks like. The second parameter is the scene node, which is the object which is affected by collision detection - in our case it is the camera. The third defines how big the object is, it is the radius of an ellipsoid. Try it out and change the radius to smaller values, the camera will be able to move closer to walls after this. The next parameter is the direction and speed of gravity. We'll set it to (0, -1000, 0), which approximates realistic gravity (depends on the units which are used in the scene model). You could set it to (0,0,0) to disable gravity. And the last value is just an offset: Without it the ellipsoid with which collision detection is done would be around the camera and the camera would be in the middle of the ellipsoid. But as human beings, we are used to have our eyes on top of the body, not in the middle of it. So we place the scene node 50 units over the center of the ellipsoid with this parameter. And that's it, collision detection works now. </p><div class="fragment"><div class="line"><span class="comment">// Set a jump speed of 300 units per second, which gives a fairly realistic jump</span></div><div class="line"><span class="comment">// when used with the gravity of (0, -1000, 0) in the collision response animator.</span></div><div class="line">scene::ICameraSceneNode* camera =</div><div class="line">    smgr-&gt;addCameraSceneNodeFPS(0, 100.0f, .3f, ID_IsNotPickable, 0, 0, <span class="keyword">true</span>, 300.f);</div><div class="line">camera-&gt;setPosition(core::vector3df(50,50,-60));</div><div class="line">camera-&gt;setTarget(core::vector3df(-70,30,-60));</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (selector)</div><div class="line">{</div><div class="line">    scene::ISceneNodeAnimatorCollisionResponse * anim = smgr-&gt;createCollisionResponseAnimator(</div><div class="line">        selector, camera, core::vector3df(30,50,30),</div><div class="line">        core::vector3df(0,-1000,0), core::vector3df(0,30,0));</div><div class="line">    selector-&gt;drop(); <span class="comment">// As soon as we&#39;re done with the selector, drop it.</span></div><div class="line">    camera-&gt;addAnimator(anim);</div><div class="line">    anim-&gt;drop();  <span class="comment">// And likewise, drop the animator when we&#39;re done referring to it.</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Now I create three animated characters which we can pick, a dynamic light for</span></div><div class="line"><span class="comment">// lighting them, and a billboard for drawing where we found an intersection.</span></div><div class="line"></div><div class="line"><span class="comment">// First, let&#39;s get rid of the mouse cursor.  We&#39;ll use a billboard to show</span></div><div class="line"><span class="comment">// what we&#39;re looking at.</span></div><div class="line">device-&gt;getCursorControl()-&gt;setVisible(<span class="keyword">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// Add the billboard.</span></div><div class="line">scene::IBillboardSceneNode * bill = smgr-&gt;addBillboardSceneNode();</div><div class="line">bill-&gt;setMaterialType(video::EMT_TRANSPARENT_ADD_COLOR );</div><div class="line">bill-&gt;setMaterialTexture(0, driver-&gt;getTexture(mediaPath + <span class="stringliteral">&quot;particle.bmp&quot;</span>));</div><div class="line">bill-&gt;setMaterialFlag(video::EMF_LIGHTING, <span class="keyword">false</span>);</div><div class="line">bill-&gt;setMaterialFlag(video::EMF_ZBUFFER, <span class="keyword">false</span>);</div><div class="line">bill-&gt;setSize(core::dimension2d&lt;f32&gt;(20.0f, 20.0f));</div><div class="line">bill-&gt;setID(ID_IsNotPickable); <span class="comment">// This ensures that we don&#39;t accidentally ray-pick it</span></div></div><!-- fragment --><p> Add 3 animated hominids, which we can pick using a ray-triangle intersection. They all animate quite slowly, to make it easier to see that accurate triangle selection is being performed.</p><div class="fragment"><div class="line">    scene::IAnimatedMeshSceneNode* node = 0;</div><div class="line"></div><div class="line">    video::SMaterial material;</div><div class="line"></div><div class="line">    <span class="comment">// Add an MD2 node, which uses vertex-based animation.</span></div><div class="line">    node = smgr-&gt;addAnimatedMeshSceneNode(smgr-&gt;getMesh(mediaPath + <span class="stringliteral">&quot;faerie.md2&quot;</span>),</div><div class="line">                        0, IDFlag_IsPickable | IDFlag_IsHighlightable);</div><div class="line">    node-&gt;setPosition(core::vector3df(-90,-15,-140)); <span class="comment">// Put its feet on the floor.</span></div><div class="line">    node-&gt;setScale(core::vector3df(1.6f)); <span class="comment">// Make it appear realistically scaled</span></div><div class="line">    node-&gt;setMD2Animation(scene::EMAT_POINT);</div><div class="line">    node-&gt;setAnimationSpeed(20.f);</div><div class="line">    material.setTexture(0, driver-&gt;getTexture(mediaPath + <span class="stringliteral">&quot;faerie2.bmp&quot;</span>));</div><div class="line">    material.Lighting = <span class="keyword">true</span>;</div><div class="line">    material.NormalizeNormals = <span class="keyword">true</span>;</div><div class="line">    node-&gt;getMaterial(0) = material;</div><div class="line"></div><div class="line">    <span class="comment">// Now create a triangle selector for it.  The selector will know that it</span></div><div class="line">    <span class="comment">// is associated with an animated node, and will update itself as necessary.</span></div><div class="line">    selector = smgr-&gt;createTriangleSelector(node, separateMeshBuffers);</div><div class="line">    node-&gt;setTriangleSelector(selector);</div><div class="line">    selector-&gt;drop(); <span class="comment">// We&#39;re done with this selector, so drop it now.</span></div><div class="line"></div><div class="line">    <span class="comment">// And this B3D file uses skinned skeletal animation.</span></div><div class="line">    node = smgr-&gt;addAnimatedMeshSceneNode(smgr-&gt;getMesh(mediaPath + <span class="stringliteral">&quot;ninja.b3d&quot;</span>),</div><div class="line">                        0, IDFlag_IsPickable | IDFlag_IsHighlightable);</div><div class="line">    node-&gt;setScale(core::vector3df(10));</div><div class="line">    node-&gt;setPosition(core::vector3df(-75,-66,-80));</div><div class="line">    node-&gt;setRotation(core::vector3df(0,90,0));</div><div class="line">    node-&gt;setAnimationSpeed(8.f);</div><div class="line">    node-&gt;getMaterial(0).NormalizeNormals = <span class="keyword">true</span>;</div><div class="line">    node-&gt;getMaterial(0).Lighting = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">// Just do the same as we did above.</span></div><div class="line">    selector = smgr-&gt;createTriangleSelector(node, separateMeshBuffers);</div><div class="line">    node-&gt;setTriangleSelector(selector);</div><div class="line">    selector-&gt;drop();</div><div class="line"></div><div class="line">    <span class="comment">// This X files uses skeletal animation, but without skinning.</span></div><div class="line">    node = smgr-&gt;addAnimatedMeshSceneNode(smgr-&gt;getMesh(mediaPath + <span class="stringliteral">&quot;dwarf.x&quot;</span>),</div><div class="line">                        0, IDFlag_IsPickable | IDFlag_IsHighlightable);</div><div class="line">    node-&gt;setPosition(core::vector3df(-70,-66,-30)); <span class="comment">// Put its feet on the floor.</span></div><div class="line">    node-&gt;setRotation(core::vector3df(0,-90,0)); <span class="comment">// And turn it towards the camera.</span></div><div class="line">    node-&gt;setAnimationSpeed(20.f);</div><div class="line">    node-&gt;getMaterial(0).Lighting = <span class="keyword">true</span>;</div><div class="line">    selector = smgr-&gt;createTriangleSelector(node, separateMeshBuffers);</div><div class="line">    node-&gt;setTriangleSelector(selector);</div><div class="line">    selector-&gt;drop();</div><div class="line"></div><div class="line">    <span class="comment">// And this mdl file uses skinned skeletal animation.</span></div><div class="line">    node = smgr-&gt;addAnimatedMeshSceneNode(smgr-&gt;getMesh(mediaPath + <span class="stringliteral">&quot;yodan.mdl&quot;</span>),</div><div class="line">                        0, IDFlag_IsPickable | IDFlag_IsHighlightable);</div><div class="line">    node-&gt;setPosition(core::vector3df(-90,-25,20));</div><div class="line">    node-&gt;setScale(core::vector3df(0.8f));</div><div class="line">    node-&gt;getMaterial(0).Lighting = <span class="keyword">true</span>;</div><div class="line">    node-&gt;setAnimationSpeed(20.f);</div><div class="line"></div><div class="line">    <span class="comment">// Just do the same as we did above.</span></div><div class="line">    selector = smgr-&gt;createTriangleSelector(node, separateMeshBuffers);</div><div class="line">    node-&gt;setTriangleSelector(selector);</div><div class="line">    selector-&gt;drop();</div><div class="line"></div><div class="line">    material.setTexture(0, 0);</div><div class="line">    material.Lighting = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Add a light, so that the unselected nodes aren&#39;t completely dark.</span></div><div class="line">    scene::ILightSceneNode * light = smgr-&gt;addLightSceneNode(0, core::vector3df(-60,100,400),</div><div class="line">        video::SColorf(1.0f,1.0f,1.0f,1.0f), 600.0f);</div><div class="line">    light-&gt;setID(ID_IsNotPickable); <span class="comment">// Make it an invalid target for selection.</span></div><div class="line"></div><div class="line">    <span class="comment">// Remember which scene node is highlighted</span></div><div class="line">    scene::ISceneNode* highlightedSceneNode = 0;</div><div class="line">    scene::ISceneCollisionManager* collMan = smgr-&gt;getSceneCollisionManager();</div><div class="line"></div><div class="line">    <span class="comment">// draw the selection triangle only as wireframe</span></div><div class="line">    material.Wireframe=<span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(device-&gt;run())</div><div class="line">    <span class="keywordflow">if</span> (device-&gt;isWindowActive())</div><div class="line">    {</div><div class="line">        driver-&gt;beginScene(video::ECBF_COLOR | video::ECBF_DEPTH, video::SColor(0));</div><div class="line">        smgr-&gt;drawAll();</div><div class="line"></div><div class="line">        <span class="comment">// Unlight any currently highlighted scene node</span></div><div class="line">        <span class="keywordflow">if</span> (highlightedSceneNode)</div><div class="line">        {</div><div class="line">            highlightedSceneNode-&gt;setMaterialFlag(video::EMF_LIGHTING, <span class="keyword">true</span>);</div><div class="line">            highlightedSceneNode = 0;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// All intersections in this example are done with a ray cast out from the camera to</span></div><div class="line">        <span class="comment">// a distance of 1000.  You can easily modify this to check (e.g.) a bullet</span></div><div class="line">        <span class="comment">// trajectory or a sword&#39;s position, or create a ray from a mouse click position using</span></div><div class="line">        <span class="comment">// ISceneCollisionManager::getRayFromScreenCoordinates()</span></div><div class="line">        core::line3d&lt;f32&gt; ray;</div><div class="line">        ray.start = camera-&gt;getPosition();</div><div class="line">        ray.end = ray.start + (camera-&gt;getTarget() - ray.start).normalize() * 1000.0f;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// This call is all you need to perform ray/triangle collision on every scene node</span></div><div class="line">        <span class="comment">// that has a triangle selector, including the Quake level mesh.  It finds the nearest</span></div><div class="line">        <span class="comment">// collision point/triangle, and returns the scene node containing that point.</span></div><div class="line">        <span class="comment">// Irrlicht provides other types of selection, including ray/triangle selector,</span></div><div class="line">        <span class="comment">// ray/box and ellipse/triangle selector, plus associated helpers.</span></div><div class="line">        <span class="comment">// You might also want to check the other methods of ISceneCollisionManager.</span></div><div class="line"></div><div class="line">        irr::io::SNamedPath hitTextureName;</div><div class="line">        scene::SCollisionHit hitResult;</div><div class="line">        scene::ISceneNode * selectedSceneNode =collMan-&gt;getSceneNodeAndCollisionPointFromRay(</div><div class="line">                    hitResult,  <span class="comment">// Returns all kind of info about the collision</span></div><div class="line">                    ray,</div><div class="line">                    IDFlag_IsPickable, <span class="comment">// This ensures that only nodes that we have</span></div><div class="line">                            <span class="comment">// set up to be pickable are considered</span></div><div class="line">                    0); <span class="comment">// Check the entire scene (this is actually the implicit default)</span></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// If the ray hit anything, move the billboard to the collision position</span></div><div class="line">        <span class="comment">// and draw the triangle that was hit.</span></div><div class="line">        <span class="keywordflow">if</span>(selectedSceneNode)</div><div class="line">        {</div><div class="line">            bill-&gt;setPosition(hitResult.Intersection);  <span class="comment">// Show the current intersection point with the level or a mesh</span></div><div class="line"></div><div class="line">            <span class="comment">// We need to reset the transform before doing our own rendering.</span></div><div class="line">            driver-&gt;setTransform(video::ETS_WORLD, core::matrix4());</div><div class="line">            driver-&gt;setMaterial(material);</div><div class="line">            driver-&gt;draw3DTriangle(hitResult.Triangle, video::SColor(0,255,0,0));   <span class="comment">// Show which triangle has been hit</span></div><div class="line"></div><div class="line">            <span class="comment">// We can check the flags for the scene node that was hit to see if it should be</span></div><div class="line">            <span class="comment">// highlighted. The animated nodes can be highlighted, but not the Quake level mesh</span></div><div class="line">            <span class="keywordflow">if</span>((selectedSceneNode-&gt;getID() &amp; IDFlag_IsHighlightable) == IDFlag_IsHighlightable)</div><div class="line">            {</div><div class="line">                highlightedSceneNode = selectedSceneNode;</div><div class="line"></div><div class="line">                <span class="comment">// Highlighting in this case means turning lighting OFF for this node,</span></div><div class="line">                <span class="comment">// which means that it will be drawn with full brightness.</span></div><div class="line">                highlightedSceneNode-&gt;setMaterialFlag(video::EMF_LIGHTING, <span class="keyword">false</span>);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// When separateMeshBuffers is set to true we can now find out which material was hit</span></div><div class="line">            <span class="keywordflow">if</span> ( hitResult.MeshBuffer &amp;&amp; hitResult.Node &amp;&amp; hitResult.Node-&gt;getMaterial(hitResult.MaterialIndex).TextureLayer[0].Texture )</div><div class="line">            {</div><div class="line">                <span class="comment">// Note we are interested in the node material and not in the meshbuffer material.</span></div><div class="line">                <span class="comment">// Otherwise we wouldn&#39;t get the fairy2 texture which is only set on the node.</span></div><div class="line">                hitTextureName = hitResult.Node-&gt;getMaterial(hitResult.MaterialIndex).TextureLayer[0].Texture-&gt;getName();</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// We&#39;re all done drawing, so end the scene.</span></div><div class="line">        driver-&gt;endScene();</div><div class="line"></div><div class="line">        <span class="comment">// Show some info in title-bar</span></div><div class="line">        <span class="keywordtype">int</span> fps = driver-&gt;getFPS();</div><div class="line">        <span class="keyword">static</span> core::stringw lastString;</div><div class="line">        core::stringw str = L<span class="stringliteral">&quot;Collision detection example - Irrlicht Engine [&quot;</span>;</div><div class="line">        str += driver-&gt;getName();</div><div class="line">        str += <span class="stringliteral">&quot;] FPS:&quot;</span>;</div><div class="line">        str += fps;</div><div class="line">        <span class="keywordflow">if</span> ( !hitTextureName.getInternalName().empty() )</div><div class="line">        {</div><div class="line">            str += <span class="stringliteral">&quot; &quot;</span>;</div><div class="line">            irr::io::path texName(hitTextureName.getInternalName());</div><div class="line">            str += core::deletePathFromFilename(texName);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> ( str != lastString )    <span class="comment">// changing caption is somewhat expensive, so don&#39;t when nothing changed</span></div><div class="line">        {</div><div class="line">            device-&gt;setWindowCaption(str.c_str());</div><div class="line">            lastString = str;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    device-&gt;drop();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<p>&nbsp;</p>
</body>
</html>
